## 新 RBAC 机制：基于资源的访问控制

这篇文章讨论了如何通过角色概念组织安全策略，及之前主要的基于角色的机制来保护应用的最大不足。我讨论的是，我认为的比较好的保护应用的方式。

### 什么是角色（Role）？

当讨论保护应用的时候，大多数人首先想到的就是已存在的*角色*的概念。角色是一种命名实体表示一组操作行为或责任。这些行为会被翻译为在软件应用中你可以或是不可以进行的操作。角色通常分配给用户，通过分配，用户可以做符合他角色的操作。

比如，如果用户登录系统，并且他被分配了“项目经理”角色，那么他将进行所有项目经理可以做的操作 - 列出所有项目，添加或移除项目成员，生成项目报表，等。

这种场景下，角色是一种行为概念：角色告诉你用户可以在应用中作什么。

### 基于角色的访问控制

由于角色主要是一种行为性概念，开发软件应用时逻辑就是通过引入角色来负责应用功能和数据的访问控制。如你所想，大多数人简单称之为“Role-Based Access Control”，或 RBAC（发音：“are-back”）。

然而，主要有两种方式去实现访问控制：*隐式*，及*显式*。

如今，大多数的应用都是基于隐式访问控制。但我肯定*显式访问控制*是保护如今软件应用的更好方式。

#### 隐式访问控制

如前所述，角色表示行为和责任。但如何**<i>确切</i>** 知道行为和责任关联到了角色呢？

然而答案是，在大多数应用中，你并不能*确切* 知道角色到底表示什么（译注：行为或操作）。你可能了然于胸 - 你知道一个“管理员”角色的用户可以锁定其他用户帐号或配置应用的特定部分，一个“消费者”角色的用户可以将商品加入购物车或请求新的商品。但是，通常没有确切定义这些行为的地方。

以字符串“Project Manager”为例。它仅仅是一个字符串，程序无法通过它就可知道“基于这个名字，我知道分配了这个角色的用户可以进行 X，Y 和 Z 操作”。开发人员也是直接使用这个名称。比如，确定用户是否有权限查看项目报表，你将会看到这样的代码：

	//Listing 1. Example Implicit Role-Based Access Control security check:
	if (user.hasRole("Project Manager") ) {
	    //show the project report button
	} else {
	    //don't show the button
	}

这个代码示例中，开发人员通过“Project Manager”角色确定是否显示一个按钮（或许是项目需求）。但是注意上面的代码并没有显式指出“Project Manager”角色允许查看项目报表。软件中并没有确切定义这种行为之处 - *隐含*“Project Manager”用户可以查看项目报告，所以开发人员编写 if/else 语句表示这种假设。

### 脆弱的安全策略

上面示例的安全控制非常脆弱。表现在很微小的安全需求变更都可能导致程序破坏、失败或低效。

想象一下这个假设场景：“噢，话说，我们需要一个新“Department Manager”角色，此类用户也可以查看项目报告。你们实现一下”。

现在，开发人员必须要找到这段代码并修改成：

	//Listing 2. Example Modified Implicit Role-Based Access Control security check:
	if (user.hasRole("Project Manager") || user.hasRole("Department Manager") ) {
	    //show the project report button
	} else {
	    //don't show the button
	}

现在开发人员必须要更新测试用例，重新构建软件，查看 QA 报告，并重新发布到生产环境 - 所有仅仅是因为一个新的微小的安全需求。

但是，如果管理层又让加一个其他新的角色可以查看报表呢？或者他们要稍后移除这种角色？

或者，如果软件需要在运行时*动态* 增加或删除角色呢，因为用户想自己控制角色配置（译注：比如定制自己的感兴趣的菜单）。

在所有这些场景中，简单的隐式（静态字符串）RBAC 方式是无法满足安全需要的。如果，仅仅是安全策略变了，最理想的方式是你无需碰源码就可支持，源码只应在数据模型变动时去进行修改。

### 显式访问控制：更好的方式

如前所看到的，隐式访问控制中的安全策略变动是灾难。安全策略改变不导致代码的重构才是比较好的安全策略。更加理想的情况是，安全策略可以在*应用运行时* 改变，并且不影响你的终端用户。这同样对安全有好处，如果你发现了错误或是危险（或者你制定了错误的策略），可以迅速改变策略，而你的应用可以一直正常使用。

那么，如何做才能获得这些好处呢？可以通过*显式*声明应用中可以做什么来实现。但是，这到底是什么意思呢？

当你看到上面的隐式访问控制，他们*到底*打算做什么？进行的最根本的控制是什么？

从根本上说，那些检查是为了保护**资源（resources）**（如项目报表）及用户对这些资源可进行得**操作（actions）**（如查看/阅读报表）。当你将访问控制拆解到最低级的程度时，你可以以更细粒度（及更高弹性）的方式描述安全策略。

比如，我们可以修改上面的代码块通过基于资源的语义来实现相同的效果：

	//Listing 3. Example Explicit Access Control security check:
	if (user.isPermitted("projectReport:view:12345")) {
	    //show the project report button
	} else {
	    //don't show the button
	}

这个示例更加“显式”，直观表达控制了*什么* 的访问。冒号分割的语法并不是重点 - 仅仅是示例。更重要的是，我们在检查“当前用户是否允许 view（查看）ID 为 12345（instance） 的 projectReport（资源），允许则显式报表按钮”。也就是说，我们在明确的为特定用户声明*特定资源实例* 的具体操作行为。

### 优点在哪里呢？

上面最新的示例有个微妙且非常重要的区别：代码现在是基于保护**什么**，而非*谁* 
具有什么能力。尽管示例代码表现上看起来（可能更加直观）很像，但是在开发和部署实践中的实际影响非常大：

 - 减少代码重构：通过抽象出资源的概念，基于应用可以执行的*操作行为*，应用程序对安全功能的核心实现将会更加通用，后续更改的频率更低。（译注：我的理解，无法做到对原文中这段的直译。:(）
 - 资源和操作行为更加直观：表示受保护的内容以及对内容的操作行为是一种更自然的思考问题的方式。面向对象的编程模型和 REST 通信模型的成功，就是因为这一思考方式。
 - 灵活的安全模型：上面的例子并不关心用户、组或角色是如何定义对于资源的允许操作。这意味着支持任何的安全模型。比如，可能直接授权给了用户操作许可。或者，可能是先分配角色，然后将角色分配给用户。或许还有组的概念以关联多个角色。类似的可能性基于你实际的应用需求是高度可定制的。
 - 外部化安全策略管理：因为源码只直接操作资源和行为并不关心用户、组和角色，他们的关联关系可以在不同的代码模块中实现或是专用工具，或是管理控制台。这意味着开发人员不需要花费时间来改变安全策略，相反，业务分析师甚至最终用户可以根据需要更改安全策略。相反，业务分析师或甚至是最终用户可以按需变更安全策略。
 - 运行时改变安全策略：因为安全相关的检查代码不必依赖于预设的关联操作（比如，组、角色和用户是如何关联的），你可以在应用运行时动态改变这种关联关系。不需要重构代码来增强安全策略，这在隐式 RBAC 中无法做到。

### 新 RBAC 机制：基于*资源* 的访问控制

除了上面列出的好处之外，我还会重申显式机制提供的灵活安全模型概念。

如果你想保留或模拟传统的基于角色的访问控制，你可以直接分配操作行为到角色。这种场景下，你仍然是基于角色的访问控制安全机制 - 仅仅是你以一种显式的 RBAC 替换了隐式的 RBAC 机制。

但是这带来个问题 - 为什么限制在角色呢？你可以直接分配操作行为给用户，或组，或任何你的安全策略所允许的东西。

这种场景下，基于上述显式资源的访问控制，RBAC 可能可以表达一个新的涵义：“基于资源的访问控制（Resource-Based Access Control）”。只是想想...

### 实际示例：Apache Shiro

如果你好奇如何在真实世界中应用这种模型，请看下 [Apache Shiro](http://shiro.apache.org/)，一个为 JVM 上的应用提供安全机制的现代框架。Shiro 支持开箱即用的基于资源的访问控制，参见 [Permission](http://shiro.apache.org/permissions.html) 的概念。

当然，你并不需要靠 Shiro 来实现文章中提到的 RBAC 优点，但通过 Shiro 的真实示例有助你理解文章中讨论的观点。

**原文：**[The New RBAC: Resource-Based Access Control](https://stormpath.com/blog/new-rbac-resource-based-access-control)