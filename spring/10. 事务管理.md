###### <center>10. 事务管理</center>
###### <center>Part IV. 数据存取</center>
----------------------------------------

### 10. 事务管理
### 10.1 Spring 事务管理简介

强大、全面的事务支持是使用 Spring 框架的一个很重要因素。Spring 为事务管理提供了一致的抽象，具有以下优势：

- 为不同规范的事务 API 比如 Java Tranaction API(JTA), JDBC, Hibernate, Java Persistence API(JPA) 及 Java Data Objects(JDO) 提供一致的编程模型。
- 支持声明式事务管理。
- 简单 API 支持编程式事务管理相比于复杂的事务 API 比如 JTA。
- 与 Spring 数据存取抽象层完美整合。

以下小节讲述了 Spring 框架的事务使用和技术（译者： ERROR?）。（本章同样包括最佳编程实践、与应用服务器整合、常见问题解决方案方面的讨论。）

- Spring 事务支持模型的优势：描述了，*为什么* 你应该使用 Spring 事务抽象而非 EJB 容器-管理级事务(EJB Container-Managed Transactions,CMT) 或是通过其他所有者的事务 API 驱动本地事务比如 Hibernate 的事务 API。
- 理解 Spring 事务抽象：概述核心类及描述如何从不同数据源配置和获取`DataSource`实例。
- 利用事务同步资源：描述应用代码如何正确的保证资源的创建、重用及清理。
- 声明式事务管理：描述对声明式事务管理的支持。
- 编程式事务管理：覆盖了对编程式（即，显示代码）事务支持。

### 10.2 Spring 事务支持模型的优势

传统而言，Java EE 开发人员有两种方式进行事务管理：*全局(global)* 或 *本地(local)* 事务，这两种都有很大的限制（译者：体现在那？）。全局和本地的事务管理将在以下两小节回顾，然后是讨论 Spring 事务管理支持是如何解决全局和本地事务模型的限制。

#### 10.2.1 全局事务

全局事务使你能跟多种事务源打交道，典型如关系型数据库和消息队列。应用服务器通过 JTA 管理全局事务，而 JTA 是相当笨重的 API(部分原因是它的异常(exception)模型)。而且，一个 JTA `UserTransaction` 通常需要从 JNDI 获取，这意味着你 *必须同时使用* JNDI。显然，全局事务的使用将会限制任何潜在的代码重用，因为 JTA 通常只在应用服务器中能得到。（译者：WHAT?）

早先，使用全局事务的首先方式是通过 EJB *CMT(Container Managed Transaction)* ：CMT 是一种 **声明式事务管理** (区分自 **编程式事务管理** )。EJB CMT 移除了与事务相关联的 JNDI 查找，尽管它本身仍需要从 JNDI 中查找。它移除了大部分但并非全部通过编写 Java 代码控制事务的必要性。CMT 的显著缺点是它绑定到 JTA 及应用服务器环境。而且，只有当实现 EJB 形式的业务逻辑时 CMT 才可用，至少也得是 EJB 事务的门面（译者：Better?）。EJB 的负面效果太严重了，因为它不是一个很有吸引力的方案，特别是在面对引人注目的声明式事务管理时。

#### 10.2.2 本地事务

本地事务是跟资源相关的，比如与 JDBC 连接相关联的事务。本地事务可能使用很简便，但也有显著的缺陷：它们无法跨多种事务资源。比如，通过 JDBC 连接管理事务的代码无法再一个全局 JTA 事务中运行。因为事务管理中没有涉及到应用服务器，因而它无法帮你保证正确的跨多种资源。(这没有任何价值，因为大部分的应用程序只使用单一的事务源。)另外一个不利面是本地事务是侵入到编程模型中的。

#### 10.2.3 Spring 一致性编程模型

Spring 解决了全局和本地事务的缺陷。它使开发人员能够使用 *一致的* 编程模型 *在任何环境下* (译注：环境代指 Global, Local, JTA, CMT)。你一次编写你的代码，就能够利用不同环境事务管理策略的优势。Spring 提供了声明式和编程式事务管理。大多数用户选择声明式事务管理，它也是大部分场景较为推荐的方式。

通过编程式事务管理，开发人员直接利用运行在底层事务之上的 Spring 事务抽象。通过首选的声明式模型，开发人员只需编写很少或是不需要编写代码即可关联到事务管理，因此不依赖于 Spring 事务 API 或任何其他事务 API。

> > ###### 你需要应用服务器支持事务管理吗？
> > Have not translated.

### 10.3 理解 Spring 事务抽象

理解 Spring 事务抽象的关键是事务 *策略概念* 。事务策略定义在 `org.springframework.transaction.PlatformTransactionManager` 接口：

	public interface PlatformTransactionManager {
		TransactionStatus getTransaction(TransactionDefinition definition) throws ransactionException;
		void commit(TransactionStatus status) throws TransactionException;
		void rollback(TransactionStatus status) throws TransactionException;
	}

这主要是一个服务提供接口(SPI)，尽管它可以通过编程方式在你的应用代码中使用。因为 `PlatformTransactionManager` 是一个 *接口* ，所以它可以很容易的被模拟或是存根(译注：WHAT?)需要的话。它没有被绑定到任何诸如 JNDI 的查找策略。`PlatformTransactionManager` 实现被定义成 Spring IoC 容器中的一个普通对象(或组件)。但这个优点就使 Spring 事务是很有价值的抽象即使你使用 JTA (译注：BETTER?)。事务代码将很容易被测试相比于直接使用 JTA。
