<!DOCTYPE html>
<html>
<head>
<title>java-nio-tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Java NIO</h2>
<ol>
<li><a href="#Java-NIO-Tutorial">Java NIO 教程</a></li>
<li>
<a href="#Java-NIO-Overview">Java NIO 概述</a>
<ul>
<li><a href="#channels-and-buffers">Channels 和 Buffers</a></li>
<li><a href="#selectors">Selectors</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Channel">Java NIO Channel</a>
<ul>
<li><a href="#channel-implementations">Channel 实现</a></li>
<li><a href="#basic-channel-example">基本 Channel 示例</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Buffer">Java NIO Buffer</a>
<ul>
<li><a href="#basicusage">基本 Buffer 使用</a></li>
<li>
<a href="#capacity-position-limit">Buffer 容量，位置和限制</a>
<ul>
<li><a href="#capacity">容量</a></li>
<li><a href="#position">位置</a></li>
<li><a href="#limit">限制</a></li>
</ul>
</li>
<li><a href="#buffertypes">Buffer 类型</a></li>
<li><a href="#allocating">分配 Buffer</a></li>
<li><a href="#writing">写数据到 Buffer 中</a></li>
<li><a href="#flip">flip()</a></li>
<li><a href="#reading">从 Buffer 读数据</a></li>
<li><a href="#rewind">rewind()</a></li>
<li><a href="#clear">clear() 和 compact()</a></li>
<li><a href="#mark">mark() 和 reset()</a></li>
<li>
<a href="#equals-and-compareto">equals() 和 compareTo()</a>
<ul>
<li><a href="#equals">equals()</a></li>
<li><a href="#compareTo">compareTo()</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Java-NIO-Scatter-Gather">Java NIO Scatter / Gather</a>
<ul>
<li><a href="#scattering-reads">Scattering Reads</a></li>
<li><a href="#gathering-writes">Gathering Writes</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Channel-to-Channel-Transfers">Java NIO 通道之间数据传送</a>
<ul>
<li><a href="#transferfrom">transferFrom()</a></li>
<li><a href="#transferto">transferTo()</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Selector">Java NIO Selector</a>
<ul>
<li><a href="#why-use-a-selector">为什么使用 Selector</a></li>
<li><a href="#creating-a-selector">创建 Selector</a></li>
<li><a href="#registering-channels-with-the-selector">向 Selector 注册 Channel</a></li>
<li>
<a href="#selectionkey">SelectionKey 的</a>
<ul>
<li><a href="#selector-interest-sets">兴趣位（Interest Set）</a></li>
<li><a href="#selector-ready-set">状态位（Ready Set）</a></li>
<li><a href="#channel-selector">Channel + Selector</a></li>
<li><a href="#attaching-objects">关联对象</a></li>
</ul>
</li>
<li>
<a href="#selecting-channels-via-a-selector">通过 Selector 选择 Channel</a>
<ul>
<li><a href="#selectedkeys">selectedKeys()</a></li>
</ul>
</li>
<li><a href="#wakeup">wakeUp()</a></li>
<li><a href="#close">close()</a></li>
<li><a href="#full-selector-example">完整 Selector 示例</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-FileChannel">Java NIO FileChannel</a>
<ul>
<li><a href="#opening-a-filechannel">打开 FileChannel</a></li>
<li><a href="#reading-data-from-a-filechannel">从 FileChannel 读数据</a></li>
<li><a href="#writing-data-to-a-filechannel">写数据到 FileChannel</a></li>
<li><a href="#closing-a-filechannel">关闭 FileChannel</a></li>
<li><a href="#filechannel-position">FileChannel 位置</a></li>
<li><a href="#filechannel-size">FileChannel 大小</a></li>
<li><a href="#filechannel-truncate">FileChannel 截断</a></li>
<li><a href="#filechannel-force">FileChannel 强制刷新</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-SocketChannel">Java NIO SocketChannel</a>
<ul>
<li><a href="#opening-a-socketchannel">打开 SocketChannel</a></li>
<li><a href="#closing-a-socketchannel">关闭 SocketChannel</a></li>
<li><a href="#reading-from-a-socketchannel">从 SocketChannel 读</a></li>
<li><a href="#writing-to-a-socketchannel">写向 SocketChannel</a></li>
<li>
<a href="#non-blocking-mode">非阻塞模式</a>
<ul>
<li><a href="#connect">connect()</a></li>
<li><a href="#write">write()</a></li>
<li><a href="#read">read()</a></li>
<li><a href="#non-blocking-mode-with-selectors">非阻塞模式和 Selector</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Java-NIO-ServerSocketChannel">Java NIO ServerSocketChannel</a>
<ul>
<li><a href="#opening-a-serversocketchannel">打开 ServerSocketChannel</a></li>
<li><a href="#closing-a-serversocketchannel">关闭 ServerSocketChannel</a></li>
<li><a href="#listening-for-incoming-connections">监听连入连接</a></li>
<li><a href="#non-blocking-mode">非阻塞模式</a></li>
</ul>
</li>
</ol>
<h3><a name="Java-NIO-Tutorial"></a> 1. Java NIO 教程</h3>
<p>Java NIO（New IO）是 Java IO API 的替代方案（Java 1.4 之后），是指传统 <a href="">Java IO</a> 和 <a href="">Java Networking</a> API 的一种替代。Java NIO 提供了一种使用 IO 的不同方式，相比于传统的 IO API。</p>
<h4>1.1 Java NIO：Channels 和 Buffers</h4>
<p>使用传统 IO API，你实际是使用的是字节流和字符流。而 NIO 中，你需要使用 channels 和 buffers。数据总是从一个 channel 读入到一个 buffer，或从一个 buffer 写向一个 channel。</p>
<h4>1.2 Java NIO：非阻塞（Non-blocking）IO</h4>
<p>Java NIO 可以使你实现非阻塞的 IO。比如，一个线程可以像一个 channel 请求读入数据到一个 buffer。当 channel 在读数据到 buffer 的时候，那个县城可以执行其他操作。一旦当数据读入到 buffer 中时，线程就可以接着处理它。这同样适用于写数据到 channel 中。</p>
<h4>1.3 Java NIO：Selectors</h4>
<p>Java NIO 包含“selector”的概念。一个 selector 是一个对象，它可以为多个 channel 监测特定事件（像：连接开启，数据到达等） 。因而，一个简单线程就可以为数据监测多个 channel。</p>
<h3><a name="Java-NIO-Overview"></a> 2. Java NIO 概述</h3>
<p>Java NIO 包含如下核心组件：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>Java NIO 当然有很多类和组件，而不止上面的 3 个，但是在我看来， <code>Channel</code>，<code>Buffer</code> 和 <code>Selector</code> 是最核心的 API。剩下的组件，像 <code>Pipe</code> 和 <code>FileLock</code> 仅仅是为了与这 3 个核心组件协作的工具类。因而，本小节，我将会重点关注于这三个组件。其他的组件会在本教程的其他小节解释到。参见本页顶的索引列表。</p>
<h4><a name="channels-and-buffers"></a> 2.1 Channels 和 Buffers</h4>
<p>一般，所有 NIO 中的 IO 都由一个 <code>Channel</code> 作为开始。一个 <code>Channel</code> 有点类似于一个流。从 <code>Channel</code> 中数据可以被读入到一个 <code>Buffer</code>。数据也可以从 <code>Buffer</code> 被写入到一个 <code>Channel</code> 中。这里是关于上述的一个图例：</p>
<p><center><img src="overview-channels-buffers.png" alt="overview-channels-buffers" /></center>
<center><strong>Java NIO：Channel 读数据到 Buffer，Buffer 写数据到 Channel。</strong></center></p>
<p>有多种 <code>Channel</code> 和 <code>Buffer</code> 类型。下面是 Java NO 中一组主要的 <code>Channel</code> 实现类：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>如你所见，这些 channel 覆盖了 UDP + TCP 网络 IO 和文件 IO。</p>
<p>有一些有趣的接口跟这些类一起工作，但是为简单起见，我不会在本节中讲述。它们将会本教程其他章节涉及到的地方解释。</p>
<p>下面是 Java NIO 中一组核心 <code>Buffer</code> 实现类：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 <code>Buffer</code> 涵盖了你可以通过 IO 发送的基本数据类型：byte，short，int，long，float，double，和 characters。</p>
<p>Java NIO 同样有一个 <code>MappedByteBuffer</code>，用于跟内存映射文件相协作。我也不会在本章节讨论这个 <code>Buffer</code>。</p>
<h4><a name="selectors"></a> 2.2 Selectors</h4>
<p>一个 <code>Selector</code> 允许一个简单线程处理多个 <code>Channel</code>。这将会很方便，如果你的应用有多个连接（Channel）处于打开状态，但每个连接只有较低的流量。</p>
<p>比如，一个聊天服务器。</p>
<p>下面是一个线程使用 <code>Selector</code> 处理 3 个 <code>Channel</code> 的示意图：</p>
<p><center><img src="overview-selectors.png" alt="overview-selectors" /></center>
<center><strong>一个线程使用一个 Selector 处理 3 个 Channel。</strong></center></p>
<p>为了使用一个 <code>Selector</code>，你需要注册 <code>Channel</code> 到它。然后你调用它的 <code>select()</code> 方法。这个方法将会一直阻塞直到一个已注册的 channel 的事件到来。一旦这个方法返回，线程就可以处理这些事件了。事件类型比如连接到达，接收到数据等。</p>
<h3><a name="Java-NIO-Channel"></a> 3. Java NIO Channel</h3>
<p>Java NIO Channel 跟流很相似，但也有一些不同：</p>
<ul>
<li>你可以同时读和写一个 Channel。流一般是单一的（只读或只写）。</li>
<li>Channel 可以被异步读写。</li>
<li>Channel 总是从 Buffer 读，写向 Buffer。</li>
</ul>
<p>像上面提到的，你可以从 Channel 读数据到 Buffer，及从 Buffer 写数据到 Channel。这里是一个示意图：</p>
<p><center><img src="overview-channels-buffers.png" alt="overview-channels-buffers" /></center>
<center><strong>Java NIO：Channel 读数据到 Buffer，Buffer 写数据到 Channel。</strong></center></p>
<h4><a name="channel-implementations"></a> 3.1 Channel 实现</h4>
<p>下面是 Java NIO 中一些最重要的 Channel 实现类：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><code>FileChannel</code> 从文件读或写数据。</p>
<p><code>DatagramChannel</code> 可以通过 UDP 协议从网络读和写数据。</p>
<p><code>SocketChannel</code> 可以通过 TCP 协议从网络读或写数据。</p>
<p><code>ServerSocketChannel</code> 允许你监听到达的 TCP 连接，像 web 服务器那样。每一个到达的链接，就会创建一个 <code>SocketChannel</code>。</p>
<h4><a name="basic-channel-example"></a> 3.2 基本 Channel 示例</h4>
<p>下面是一个基本示例，使用 <code>FileChannel</code> 读取一些数据到 Buffer：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {

    System.out.println(&quot;Read &quot; + bytesRead);
    buf.flip();

    while (buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();
</code></pre>

<p>注意 <code>buf.flip()</code> 调用。首先你读到一个 Buffer 中。然后，你切换读写模式。然后，读出它。我将会在下一小节讲解更多关于 <code>Buffer</code> 的细节。</p>
<h3><a name="Java-NIO-Buffer"></a> 4. Java NIO Buffer</h3>
<p>Java NIO Buffer 用于跟 NIO Channel 交互。如你所知，数据从 Channel 读入 Buffer，从 Buffer 写向 Channel。</p>
<p>一个 Buffer，本质是一块内存区域，你可以写入数据到其中，并之后进行重读。这块内存区域被包装成 NIO Buffer 对象，这些对象提供了一系列方法使的更易于跟内存块一起工作。</p>
<h4><a name="basicusage"></a> 4.1 基本 Buffer 使用</h4>
<p>使用一个 Buffer 来读和写数据，一般有 4 步：</p>
<ol>
<li>写数据到 Buffer 中</li>
<li>调用 buffer.flip()</li>
<li>从 Buffer 读取读数</li>
<li>调用 buffer.clear() 或 buffer.compact()</li>
</ol>
<p>当你写数据到 Buffer 中，这个 Buffer 会记录你已经写了多少数据。一旦，你需要读数据，就需要通过 <code>flip()</code> 来切换 Buffer 从写模式到读模式。读模式下，Buffer 可以使你读到所有已写入 Buffer 的数据。</p>
<p>一旦你读完了所有数据，你需要清空 Buffer，使它可以做好准备再次写入。你可以通过两种方式实现：调用 <code>clear()</code> 或调用 <code>compant()</code>。<code>clear()</code> 方法清空整个 Buffer。<code>compact()</code> 方法仅仅清空你已经读过的数据。所有未读数据将会被移动到 Buffer 的开始位置，然后数据将会被写入到 Buffer 中未读数据的后面。</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {

    System.out.println(&quot;Read &quot; + bytesRead);
    buf.flip();

    while (buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();
</code></pre>

<h4><a name="capacity-position-limit"></a> 4.2 Buffer 容量，位置和限制</h4>
<p>下面是一个简单实用 <code>Buffer</code> 的示例，包括写，切换，读和清空操作：</p>
<p>一个 Buffer 本质上是一块内存区域，你可以写入数据到其中，并之后再次阅读。这块内存区域被包装成 NIO Buffer 对象，这些对象提供了一系列方法使的更易于跟内存块一起工作。</p>
<p>一个 Buffer 有 3 个你需要熟悉的属性，才能理解一个 <code>Buffer</code> 是如何工作的。它们是：</p>
<ul>
<li>容量（capacity）</li>
<li>位置（position）</li>
<li>限制（limit）</li>
</ul>
<p><code>position</code> 和 <code>limit</code> 的实际含义依赖于 <code>Buffer</code> 是处于读还是写模式。容量总是同一个含义，跟 Buffer 模式无关。</p>
<p>下面是容量、位置和限制在写和读模式下的示意图。示意图的解释在下一小节。</p>
<p><center><img src="buffers-modes.png" alt="buffers-modes" /></center>
<center><strong>写和读模式下 Buffer 容量，位置和限制。</strong></center></p>
<h5><a name="capacity"></a> 4.2.1 容量（capacity）</h5>
<p>一个内存块，即一个 <code>Buffer</code> 有一个确定的尺寸，也叫做它的“capacity”。你只能写 <code>catacity</code> 长度的 byte，long 和 char 等到 Buffer 中。一旦 Buffer 满了，你需要先清空它（读数据，或清空它），在你可以再次写入更多数据之前。</p>
<h5><a name="position"></a> 4.2.2 位置（position）</h5>
<p>当你写入数据到 <code>Buffer</code> 中，你会设置一个指定 position。初始化时 position 是 0。当一个 byte，long 等已经被写入到 <code>Buffer</code> 中，position 就会前进到下一个 Buffer 中的格子来插入下个数据。position 最大可以变成 <code>capacity - 1</code>。</p>
<p>当你从 <code>Buffer</code> 中读入数据时，你也同样需要根据当前 position 来设置新 position。当你切换一个 <code>Buffer</code> 从写模式到读模式时，position 将被重设成 0。当你从 <code>Buffer</code> 读入数据时，也将会变动 <code>position</code> 值，即前进 <code>position</code> 到下个被读的位置。</p>
<h5><a name="limit"></a> 4.2.3 限制（limit）</h5>
<p>写模式下，一个 <code>Buffer</code> 的 limit 是你可以写入多少数据到 Buffer 中。写模式下，limit 是等于 <code>Buffer</code> capacity 的。</p>
<p>当切换 <code>Buffer</code> 到读模式，limit 表示你可以从 Buffer 中读多少数据（译注：原文是 from the data，应该是错误的，data 应该是 buffer）。因而，当切换一个 <code>Buffer</code> 到读模式，limit 值被设置成写模式下写入数据时的最后 position。换句话说，你写了多少数据就可以读入多少数据（limit 被设置成已写字节（译注：应该是指定类型的数据）的数量，即 position 值）。</p>
<h4><a name="buffertypes"></a> 4.3 Buffer 类型</h4>
<p>Java NIO 中有以下 <strong>Buffer</strong> 类型：</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>如你所见，这些 <code>Buffer</code> 类型用于表示不同的数据类型。换句话说，它们使你可以对待 Buffer 中的字节成 char，short，int，long，float 或 double 类型。</p>
<p><code>MappedByteBuffer</code> 有点特殊，将会在自己小节中讲解。</p>
<h4><a name="allocating"></a> 4.4 分配 Buffer</h4>
<p>为了获得一个 <code>Buffer</code> 对象，你必须先分配它。每个 <code>Buffer</code> 类都有一个 <code>allocate()</code> 方法，来实现分配操作。下面是一个例子展示了对 <code>ByteBuffer</code> 的分配，容量 48 字节：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
</code></pre>

<p>下面的例子分配一个 <code>CharBuffer</code>，容量为 1024 个 char：</p>
<pre><code>CharBuffer buf = CharBuffer.allocate(1024);
</code></pre>

<h4><a name="writing"></a> 4.5 写数据到 Buffer 中</h4>
<p>你可以写数据到 <code>Buffer</code> 中，有两种方式：</p>
<ol>
<li>从 <code>Channel</code> 写数据到 <code>Buffer</code> 中。</li>
<li>直接通过 <code>Buffer</code> 写入数据，通过 Buffer 的 <code>put()</code> 方法。</li>
</ol>
<p>下面的例子展示一个 <code>Channel</code> 如何写入数据到 <code>Buffer</code> 中：</p>
<pre><code>int bytesRead = inChannel.read(buf); //read into buffer.
</code></pre>

<p>下面的例子是写入数据到 <code>Buffer</code> 中，通过 <code>put()</code> 方法：</p>
<pre><code>buf.put(127);
</code></pre>

<p>有很多其他版本的 <code>put()</code> 方法，允许你通过多种方式写数据到 <code>Buffer</code> 中。比如，在特定的位置写入数据，或写一个字节数组到 Buffer 中。具体 Buffer 实现类的细节，参见 JavaDoc。</p>
<h4><a name="flip"></a> 4.6 flip()</h4>
<p><code>flip()</code> 方法切换 <code>Buffer</code> 从写模式到读模式。调用 <code>flip()</code> 会设置 <code>position</code> 成 0，并设置 <code>limit</code> 为 position 值。</p>
<p>换句话说，<code>position</code> 现在标记读的位置，<code>limit</code> 标记多少字节，字符等被入到 Buffer 中，即多少字节，字符等可以被读出。</p>
<h4><a name="reading"></a> 4.7 从 Buffer 读数据</h4>
<p>有两种方式，你可以从 <code>Buffer</code> 读入数据。</p>
<ol>
<li>从 Buffer 读数据到一个 Channel。</li>
<li>从 Buffer 本身读取数据，通过 <code>get()</code> 方法。</li>
</ol>
<p>下面的例子展示你如何从 Buffer 读数据到一个 Channel 中：</p>
<pre><code>//read from buffer into channel.
int bytesWritten = inChannel.write(buf);
</code></pre>

<p>下面的例子展示了通过 <code>get()</code> 方法从 <code>Buffer</code> 读入数据：</p>
<pre><code>byte aByte = buf.get();
</code></pre>

<p>还有很多其他版本的 <code>get()</code> 方法，允许你从 <code>Buffer</code> 以多种方式读数据。比如，读取特定位置的数据，从 Buffer 读取一个字节数组。具体 Buffer 实现类的细节，参见 JavaDoc。</p>
<h4><a name="rewind"></a> 4.7 rewind()</h4>
<p><code>Buffer.rewind()</code> 重新设置 <code>position</code> 成 0，这样你可以重新读取 Buffer 中的所有数据。<code>limit</code> 值不会变化，即仍标记可以从 <code>Buffer</code> 读取多少元素（字节，字符等）。</p>
<h4><a name="clear"></a> 4.8 clear() 和 compact()</h4>
<p>一旦你完成了从 <code>Buffer</code> 读取数据，你必须使 <code>Buffer</code> 做好准备再次被写入。你可以通过调用 <code>clear()</code> 或 <code>compact()</code> 来做到这个。</p>
<p>如果你调用 <code>clear()</code> 方法，将会设置 <code>position</code> 成 0，<code>limit</code> 成 <code>capacity</code> 值。换句话说，<code>Buffer</code> 被清空了。<code>Buffer</code> 中的实际数据并没有被清空。这些标记变量仅仅告诉你可以从哪里写入数据到 <code>Buffer</code> 中。</p>
<p>如果 <code>Buffer</code> 中还有未被读取的数据，当你调用 <code>clear()</code> 的时候，这些数据将会被“遗忘”，即你不再有任何标记变量告诉你什么数据已经读过了，什么数据还没有被读过。</p>
<p>如果 <code>Buffer</code> 中仍有未被读取的数据，而且你还想在之后读取，但你需要首先做一些写入操作，则需要调用 <code>compact()</code> 方法而非 <code>clear()</code>。</p>
<p><code>compact()</code> 复制这些未读数据到 <code>Buffer</code> 中起始位置。然后，设置 <code>position</code> 为最右边的未读元素的索引。<code>limit</code> 值设置成 <code>capacity</code> 值，就像 <code>clear()</code> 方法所做的那样。现在，<code>Buffer</code> 已经是可以再次写入的状态了，但你并没有复写未读数据。</p>
<h4><a name="mark"></a> 4.9 mark() 和 reset()</h4>
<p>你可以在 <code>Buffer</code> 中标记一个给定的 position，通过调用 <code>Buffer.mark()</code> 方法。然后，你可以重设 position 到这个已标记的 position，通过调用 <code>Buffer.reset()</code> 方法。下面是一个例子：</p>
<pre><code>buffer.mark();
//call buffer.get() a couple of times, e.g. during parsing.
buffer.reset();  //set position back to mark.
</code></pre>

<h4><a name="equals-and-compareto"></a> 4.10 equals() 和 compareTo()</h4>
<p>可以比较两个 Buffer， 通过 <code>equals()</code> 和 <code>compareTo()</code>。</p>
<h5><a name="equals"></a> 4.10.1 equals()</h5>
<p>两个 Buffer 是相等的，如果（译注：同时满足 3 个条件）：</p>
<ol>
<li>它们具有相同的类型（字节，字符，整形等）。</li>
<li>它们的 Buffer 中有同等数量的未读（译注：此处为 remaining，翻译成“未读”？）字节，字符等。</li>
<li>所有的字节，字符等是相等的。</li>
</ol>
<p>如你所见，equals 方法仅仅比较 <code>Buffer</code> 的一部分，而非其中的每一个元素。其实，它仅比较 <code>Buffer</code> 中的未读元素。</p>
<h5><a name="compareTo"></a> 4.10.2 compareTo()</h5>
<p><code>compareTo()</code> 方法比较两个 Buffer 的剩余元素（字节，字符等），比如，排序例程。一个 Buffer “小于”另一个 Buffer 如果：</p>
<ol>
<li>Buffer 中第一个元素小于另一个 Buffer 中的相应元素。</li>
<li>所有的元素是相等的，但是第一个 Buffer 先于第二个 Buffer 读（耗）尽了所有元素（即，第一个 Buffer 有较少的元素）。</li>
</ol>
<h3><a name="Java-NIO-Scatter-Gather"></a> 5. Java NIO 散和收（Sactter/Gather）</h3>
<p>Java NIO 有内建的 scatter / gather 支持。scatter / gather 的概念用于读 / 写 channel。</p>
<p>一个 scattering 用于从 channel 执行读操作，读数据到一个或多个 buffer 中。因而，channel 用于从多个通道“分散”数据到多个缓冲区中。</p>
<p>一个 gathering 写向 channel 是一个写操作来写数据到 channel 中，可以从一或多个缓冲区中写数据到一个单一的 channel。</p>
<p>scatter / gather 会是很有用的解决方案，当你需要用分开使用多种类的数据时。比如，如果一个消息由一个头（header）和正文（body）组成，你可能想将头和正文放在分开的缓冲区中。这样做，可以使你更易于以分离的方式使用头和正文。</p>
<h4><a name="scattering-reads"></a> 5.1 分散读（Scattering Reads）</h4>
<p>一个“散开读”从一个单一通道中读数据到多个缓冲区中。下面是这个原理的实例图：</p>
<p><center><img src="scatter.png" alt="scatter" /></center>
<center><strong>Java NIO：分散读</strong></center></p>
<p>这面这个例子展示如何实现一个分散读：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);

ByteBuffer[] bufferArray = { header, body };

channel.read(buffers);
</code></pre>

<p>注意，实例化后的缓冲区先被插入到数组中的，然后数组作为参数传递到 <code>channel.read()</code> 方法。然后，<code>read()</code> 方法按照数组中缓冲区的顺序，从通道中写数据到数组中的缓冲区实例。一旦一个缓冲区写满了，通道转向下一个，并填满它。</p>
<p>分散读填满一个缓冲区之后才会转向下一个，这意味着动态大小的消息部分并不适合使用分散读。换句话说，如果你有一个头和正文，而且头有固定尺寸（如，128 字节），那么分散度将会相当有效。</p>
<h4><a name="gathering-reads"></a> 5.2 收集写（Gathering Writes）</h4>
<p>一个“收集写”从多个缓冲区中写数据到一个单一通道中。下面是这个原理的示意图：</p>
<p><center><img src="gather.png" alt="gather" /></center>
<center><strong>Java NIO：收集写</strong></center></p>
<p>下面的代码示例展示如何实现一个收集写：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);

//write data into buffers

ByteBuffer[] bufferArray = { header, body };

channel.write(buffers);
</code></pre>

<p>缓冲区数组传递到 <code>write()</code> 方法，该方法按照数组中缓冲区的顺序将内容写到通道中。仅仅在 position 和 limit 之间的缓冲区内容才会被写出。因而，如果一个缓冲区的容量为 128 字节，但仅包含 58 字节的实际数据，那么只会有这 58 字节从缓冲区写向通道中。因此，一个收集写在消息大小是动态变化时将会工作的很好，跟分散读相反。</p>
<h3><a name="Java-NIO-Channel-to-Channel-Transfers"></a> 6. Java NIO 通道之间数据传送</h3>
<p>Java NIO 中，你可以直接将数据从一个通道转到另一个通道中，如果通道中的一个是 <code>FileChannel</code> 的话。<code>FileChannel</code> 类有一个 <code>transferTo()</code> 和一个 <code>transferFrom()</code> 方法，来完成数据转送操作。</p>
<h4><a name="transferfrom"></a> 6.1 transferFrom()</h4>
<p><code>FileChannel.transferFrom()</code> 方法从一个源通道转送数据到另一个 <code>FileChannel</code>。</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel      fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel      toChannel = toFile.getChannel();

long position = 0;
long count    = fromChannel.size();

toChannel.transferFrom(fromChannel, position, count);
</code></pre>

<p>position 和 count 参数，告诉目标（被写入）文件从哪里开始写数据（<code>position</code>），及应该转送最大多大（<code>count</code>）字节的数据。如果源通道数据量少于 <code>count</code> 字节，那么将只转送能够转送的数据量。</p>
<p>另外，一些 <code>SocketChannel</code> 实现可能也可以转送数据，这些数据只是 <code>SocketChannel</code> 中当前已经在内部缓冲区中的了，即使 <code>SocketChannel</code> 中可能后续有很多的数据进来。因而，它可能无法从 <code>SocketChannel</code> 转送全部的所要求的（<code>count</code>）数据到 <code>FileChannel</code> 中。</p>
<h4><a name="transferfrom"></a> 6.2 transferto()</h4>
<p><code>transferTo()</code> 方法用于从 <code>FileChannel</code> 转数据到其它通道。下面是一个简单示例：</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel      fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel      toChannel = toFile.getChannel();

long position = 0;
long count    = fromChannel.size();

fromChannel.transferTo(position, count, toChannel);
</code></pre>

<p>注意，这个例子跟前例非常相似。唯一真正的不同是，这个方法是在哪个 <code>FileChannel</code> 对象调用的。其它都是相同的。</p>
<p>问题是，<code>SocketChannel</code> 也提供了一个 <code>transferTo()</code> 方法。<code>SocketChannel</code> 实现可能只会从 <code>FileChannel</code> 中转送字节直到发送缓冲区满了（send buffer），然后停止（译注：挂起？）。</p>
<h3><a name="Java-NIO-Selector"></a> 7. Java NIO Selector</h3>
<p>一个 <code>Selector</code> 是 Java NIO 的一个组件，用于检查一或多个 NIO Channel，并决定 Channel 状态，如读或写。这样，一个单线程就可以管理多个通道，及多个网络连接。</p>
<h4><a name="why-use-a-selector"></a> 7.1 为什么使用 Selector</h4>
<p>只使用一个线程来处理多个通道的优点是你只需较少的线程来处理通道。其实，你可以只用一个线程来处理你所有的通道。操作系统中，线程间的切换是很重的操作，而且每个线程都需要一些资源（内存）。因而，越少的线程使用，越好。</p>
<p>但是记住，现在操作系统和 CPU 在多任务的处理上变的越来越好，所以多线程的切换代价变的越来越小。其实，如果一个 CPU 由多核，你可能在浪费 CPU 的能力，如果不使用多任务的话。不过，那种设计讨论是另外的主题。这里，只讨论通过单个线程利用 <code>Selector</code> 处理多个通道。</p>
<p>下面是一个线程利用 <code>Selector</code> 处理 3 个 <code>Channel</code> 的例子：</p>
<p><center><img src="overview-selectors.png" alt="overview-selectors" /></center>
<center><strong>一个线程使用一个 Selector 处理 3 个 Channel。</strong></center></p>
<h4><a name="creating-a-selector"></a> 7.2 创建 Selector</h4>
<p>你通过调用 <code>Selector.open()</code> 方法创建一个 <code>Selector</code>，像这样：</p>
<pre><code>Selector selector = Selector.open();
</code></pre>

<h4><a name="registering-channels-with-the-selector"></a> 7.3 向 Selector 注册 Channel</h4>
<p>为了搭配 <code>Selector</code> 使用 <code>Channel</code>，你必须注册 <code>Channel</code> 到 <code>Selector</code>。这通过 <code>SelectableChannel.register()</code> 方法实现，如下：</p>
<pre><code>channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
</code></pre>

<p><code>Channel</code> 必须处于非阻塞模式，才能搭配使用 <code>Selector</code>。这意味着，你不能为 <code>FileChannel</code> 使用 <code>Selector</code>，因为 <code>FileChannel</code> 无法切换到非阻塞模式。Socket channel 将会工作的很好。</p>
<p>注意 <code>register()</code> 方法的第二个参数。这是一个“兴趣位（interest set）”，表示你为 <code>Channel</code> 设置对哪种事件感兴趣，通过 <code>Selector</code>。你可以监听 4 种事件：</p>
<ol>
<li>连入（Connect）</li>
<li>允许（Accept）</li>
<li>读（Read）</li>
<li>写（Write）</li>
</ol>
<p>一个 <code>Channel</code> “激活一个事件（fire an event）”，也叫做“准备好（ready）”处理这个事件。所以，一个已经成功连接上另一个服务器的通道处于“可接受连接状态（connect ready）”状态。一个 server socket 通道，允许接受连接，处于“允许（accept）”状态。一个通道有数据可以被读取处于“读”状态。一个通道准备好向其写数据处于“写”状态。</p>
<p>这 4 个状态被定义成 <code>SelectionKey</code> 的 4 个常量：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelecitonKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果，你对不止一个事件感兴趣，用“或”操作符连起它们，如：</p>
<pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>

<p>我将会在本文下面更多的讲解“兴趣位”。</p>
<h4><a name="selectionkey"></a> 7.4 SelectionKey 的</h4>
<p>如你在前面小节中所见，当你通过 <code>register()</code> 方法注册 <code>Channel</code> 到 <code>Selector</code> 时，返回一个 <code>SelectionKey</code> 对象。这个 <code>SelectionKey</code> 对象包括一组兴趣属性：</p>
<ul>
<li>兴趣位（interest set）</li>
<li>准备状态位（ready set）</li>
<li>通道</li>
<li>Selection</li>
<li>关联对象（可选）</li>
</ul>
<p>我将在下面描述这些属性。</p>
<h5><a name="selector-interest-sets"></a> 7.4.1 兴趣位（Interest Set）</h5>
<p>兴趣位是一组你感兴趣的事件，如在“向 Selection 注册 Channel”所描述。你可以通过 <code>SelectionKey</code> 读和写兴趣位，像这样：</p>
<pre><code>int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;   
</code></pre>

<p>如你所见，你可以通过“&amp;”操作符连接 <code>SelectionKey</code> 常量变量来设置设置兴趣位，以此确定一个事件是否在兴趣位中。</p>
<h5><a name="selector-ready-set"></a> 7.4.2 状态位（Ready Set）</h5>
<p>准备状态位描述一组通道预备好的可以执行的操作。你将在得到 selection 后获取状态位。Selection 在下面小节中解释。你通过如下操作获取状态位：</p>
<pre><code>int readySet = selectionKey.readyOps();
</code></pre>

<p>你可以按这种方式来获取其他兴趣位，什么事件 / 操作这个通道处于准备完成状态。但是，你也可以使用下面 4 个方法，都是返回 boolean 值：</p>
<pre><code>selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
</code></pre>

<h5><a name="channel-selector"></a> 7.4.3 Channel + Selector</h5>
<p>从 <code>SelectionKey</code> 获取 channel 和 selector 很简单。按照下面操作：</p>
<pre><code>Channel  channel  = selectionKey.channel();

Selector selector = selectionKey.selector(); 
</code></pre>

<h5><a name="attaching-objects"></a> 7.4.4 关联对象</h5>
<p>你可以关联对象到一个 <code>SelectionKey</code>，这可以通过手动方式由通道得到关联对象，或关联更多信息到通道。比如，你可以关联你的通道正使用的 <code>Buffer</code>，或一个包括聚合数据的对象。下面是如何关联到对象的操作：</p>
<pre><code>selectionKey.attach(theObject);

Object attachedObj = selectionKey.attachment();
</code></pre>

<p>你也可以关联对象，在向 <code>Selector</code> 注册 <code>Channel</code> 的时候，在 <code>register()</code> 方法中。下面是示例：</p>
<pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
</code></pre>

<h4><a name="selecting-channels-via-a-selector"></a> 7.5 通过 Selector 选择 Channel</h4>
<p>一旦你已经注册一或多个通道到 <code>Selector</code>，你可以通过 <code>select()</code> 方法选择其中一个。这些方法返回准备好某种状态（你所感兴趣的，connect，accept，read 或 write）的通道。换句话说，如果你对准备好读的通道“感兴趣”，通过 <code>select()</code> 方法你将获得这个准备好读的通道。</p>
<p>下面是一些 <code>select()</code> 方法：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p><code>select()</code> 方法阻塞，直到至少一个通道准备好了注册的事件。</p>
<p><code>select(long timeout)</code> 跟 <code>select()</code> 一样除了它最多阻塞 <code>timeout</code> 毫秒（参数）。</p>
<p><code>selectNow()</code> 完全不阻塞。它返回现在处于准备完成状态的任何通道。</p>
<p><code>select()</code> 方法的返回值是 <code>int</code> 类型，告诉你多少通道处于准备状态。即，多少通道处于准备状态，自从你上次调用过 <code>select()</code>。如果你调用 <code>select()</code> 并返回 1，因为一个通道处于准备状态，多次调用 <code>select()</code>， 并且多个通道处于准备状态，它将会再次返回 1。如果你没有用第一个准备状态的通道，你现在将会有 2 个处于准备状态的通道，但是在每次调用 <code>select()</code> 之间，只有 1 个通道已经变成准备状态。</p>
<h5><a name="selectedkeys"></a> 7.5.1 selectedKeys()</h5>
<p>一旦你调用了某一个 <code>select()</code> 方法，它的返回值表示一或多个通道处于准备状态，你可以通过调用 selector 的 <code>selectedKeys()</code> 方法来获得所有处于准备状态的通道。</p>
<p>Set<SelectionKey> selectedKeys = selector.selectedKeys();</p>
<p>当你注册一个通道到 <code>Selector</code>，<code>Channel.register()</code> 方法返回一个 <code>SelectionKey</code> 对象。这个 key 表示通道注册到的 selector。你可以通过 <code>selectedKeySet()</code> 方法得到这些 key。从 <code>SelectionKey</code>。</p>
<p>你可以遍历这些 selected key set 来获得这些处于准备状态的通道。下面是这个的示例：</p>
<pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();

Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
}
</code></pre>

<p>这个循环遍历 selected key 集中的 key。对每一个 key，它测试这个 key 来决定这个 key 指向的通道所处的状态。</p>
<p>注意每次遍历最后的 <code>keyIterator.remove()</code> 方法。<code>Selector</code> 不会自己从 selected key 集中移除 <code>SelectionKey</code> 实例。当你完成对通道的处理，你需要自己做这个。下次通道变成准备状态时，<code>Selecotr</code> 将会再次将它添加到 selected key 集中。</p>
<p><code>SelectionKey.channel()</code> 方法返回的通道需要被转型成你真正要用的通道，比如一个 <code>ServerSockterChannel</code> 或 <code>SocketChannel</code> 等。</p>
<h4><a name="wakeup"></a> 7.6 wakeUp()</h4>
<p>一个已经调用了 <code>select()</code> 方法而阻塞的线程，可以从 <code>select()</code> 方法返回，即使没有通道处于准备状态。这是由一个不同的线程调用 <code>Selector</code> 上的 <code>Selector.wakeup()</code> 方法，在第一个已经调用 <code>select()</code> 的线程上。这个线程在内部等待 <code>select()</code>，然后立即返回。</p>
<p>如果一个不同线程调用 <code>wakeup()</code>，而且没有任何线程当前内部处于 <code>select()</code> 阻塞状态，下一个调用 <code>select()</code> 的线程将会立即“唤醒”。</p>
<h4><a name="close"></a> 7.7 close()</h4>
<p>当你完成了 <code>Selector</code>，你需要调用它的 <code>close()</code> 方法。这将会关闭 <code>Selector</code> 并且移除所有注册到 <code>Selector</code> 的 <code>SelectionKey</code> 的实例。通道并没有关闭。</p>
<h4><a name="full-selector-example"></a> 7.8 完整 Selector 示例</h4>
<p>下面是一个完整示例，打开一个 <code>Selector</code>，注册通道（通道实例化没有包括在本例中），并且检测 <code>Selector</code> 的 4 种状态（accept，connect，read，write）。</p>
<pre><code>Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);


while(true) {

  int readyChannels = selector.select();

  if(readyChannels == 0) continue;


  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();

  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

  while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
  }
}
</code></pre>

<h3><a name="Java-NIO-FileChannel"></a> 8. Java NIO FileChannel</h3>
<p>Java NIO FileChannel 是一个通道用于连接到文件。使用文件通道，你可以从文件读取数据，并向文件写数据。Java NIO FileChannel 类是 NIO 的对 <a href="#http://tutorials.jenkov.com/java-io/file.html">利用标准 Java IO API 读文件</a>的一个替代。</p>
<p><code>FileChannel</code> 无法设置成非阻塞模式。它总是运行在阻塞模式中。</p>
<h4><a name="opening-a-filechannel"></a> 8.1 打开 FileChannel</h4>
<p>在你使用 <code>FileChannel</code> 之前，你必须打开它。你不能直接打开一个 <code>FileChannel</code>。你需要从输入流（InputStream），输出流（OutputStream），或 RandomAccessFile 中获取 FileChannel。下面是如何通过 RndomAccessFile 打开 FileChannel。</p>
<pre><code>RandomAccessFile aFile     = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel      inChannel = aFile.getChannel();
</code></pre>

<h4><a name="reading-data-from-a-filechannel"></a> 8.2 从 FileChannel 读数据</h4>
<p>你可以调用 <code>read()</code> 从 <code>FileChannel</code> 读数据。下面是一个示例：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
</code></pre>

<p>首先，分配一个 <code>Buffer</code>。从 <code>FileChannel</code> 读数据到 <code>Buffer</code> 中。</p>
<p>然后，<code>FileChannel.read()</code> 方法被调用。这个方法从 <code>FileChannel</code> 读数据到 <code>Buffer</code> 中。<code>read()</code> 方法返回 <code>int</code> 值，告诉你写到 <code>Buffer</code> 中了多少字节。如果返回的是 -1，那么表示到达了文件结尾。</p>
<h4><a name="writing-data-to-a-filechannel"></a> 8.3 写数据到 FileChannel</h4>
<p>通过 <code>FileChannel.write()</code> 方法，可以写数据到 <code>FileChannel</code> 中，它需要 <code>Buffer</code> 作为参数。下面是一个示例：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
        channel.write(buf);
}
</code></pre>

<p>注意如何在 while 循环中调用 <code>FileChannel.write()</code> 方法。并不保证 <code>write()</code> 方法写多少字节到 <code>FileChannel</code> 中。因而，我们重复调用 <code>write()</code> 方法直到 <code>Buffer</code> 中没有能写出的字符。</p>
<h4><a name="closing-a-filechannel"></a> 8.4 关闭 FileChannel</h4>
<p>当你用过 <code>FileChannel</code> 之后，你必须关闭它。如下操作：</p>
<pre><code>channel.close(); 
</code></pre>

<h4><a name="filechannel-position"></a> 8.5 FileChannel 位置</h4>
<p>当读或写一个 <code>FileChannel</code> 时，你是在一个指定位置操作的。通过调用 <code>position()</code> 方法，你可以获得 <code>FileChannel</code> 对象的当前位置。</p>
<p>你也可以通过调用 <code>position(long pos)</code> 方法设置 <code>FileChannel</code> 的位置信息。</p>
<p>下面是两个例子：</p>
<pre><code>long pos channel.position();

channel.position(pos +123);
</code></pre>

<p>如果你设置位置在文件末尾，并尝试从通道中读取数据，你将会得到 -1，标记文件结尾。</p>
<p>如果你设置位置在文件末尾，并向通道中写数据，文件将会先扩容到这个位置然后写入数据。这可能导致“文件空洞（file hole）”，即写入数据到磁盘上的物理文件有空隙。</p>
<h4><a name="filechannel-size"></a> 8.6 FileChannel 大小</h4>
<p><code>FileChannel</code> 对象的 <code>size()</code> 方法返回文件通道连接的文件的大小。</p>
<pre><code>long fileSize = channel.size();
</code></pre>

<h4><a name="filechannel-truncate"></a> 8.7 FileChannel 截断</h4>
<p>你可以截断一个文件通过 <code>FileChannel.truncate()</code> 方法。当你截断一个文件时，你切断文件成给定的长度。下面是一个示例：</p>
<pre><code>channel.truncate(1024);
</code></pre>

<p>这个例子截断文件成 1024 字节。</p>
<h4><a name="filechannel-force"></a> 8.8 FileChannel 强制刷新</h4>
<p><code>FileChannel.force()</code> 方法刷新所有通道中的未写数据到磁盘上。操作系统出于性能原因可能会在内存中缓存数据，所以无法保证数据写到通道中就是实际就写到磁盘中了，直到你调用 <code>force()</code> 方法。</p>
<p><code>force()</code> 方法需要一个 boolean 参数，表示是否将文件元数据（权限等）也同样刷新到文件中。</p>
<p>下面是一个例子，同时刷新文件数据和文件元数据。</p>
<pre><code>channel.force(true);
</code></pre>

<h3><a name="Java-NIO-SocketChannel"></a> 9. Java NIO SocketChannel</h3>
<p>Java NIO SocketChannel 是一个连接 TCP 网络端口的通道。它是 Java NIO 中的对 <a href="http://tutorials.jenkov.com/java-networking/sockets.html">Java 网络编程</a>的替代。有两种创建 <code>SocketChannel</code> 的方式：</p>
<ol>
<li>你打开一个 <code>SocketChannel</code> 并连到一个网络上的服务器。</li>
<li>一个 <code>SocketChannel</code> 将会被创建，当一个连接到达 <a href="#Java-NIO-ServerSocketChannel">ServerSocketChannel</a> 时。</li>
</ol>
<h4><a name="opening-a-socketchannel"></a> 9.1 打开 SocketChannel</h4>
<p>下面是如何打开一个 <code>SocketChannel</code>：</p>
<pre><code>SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));
</code></pre>

<h4><a name="closing-a-socketchannel"></a> 9.2 关闭 SocketChannel</h4>
<p>你通过调用 <code>SocketChannel.close()</code> 方法来关闭一个 <code>SocketChannel</code>。下面是一个示例：</p>
<pre><code>socketChannel.close();
</code></pre>

<h4><a name="reading-from-a-socketchannel"></a> 9.3 从 SocketChannel 读</h4>
<p>通过 <code>read()</code> 方法从 <code>SocketChannel</code> 读数据。下面是一个例子：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = socketChannel.read(buf);
</code></pre>

<p>首先，一个 <code>Buffer</code> 被分配创建。从 <code>SocketChannel</code> 读数据到 <code>Buffer</code> 中。</p>
<p>然后，调用 <code>SocketChannel.read()</code> 方法。这个方法从 <code>SocketChannel</code> 读数据到 <code>Buffer</code> 中。<code>read()</code> 方法返回一个 <code>int</code> 值，告诉多少字节被写到 <code>Buffer</code> 中。如果返回的是 -1，表示到达了流的结尾（连接关闭）。</p>
<h4><a name="writing-to-a-socketchannel"></a> 9.4 写向 SocketChannel</h4>
<p>使用 <code>SocketChannel.write()</code> 方法写数据到 <code>SocketChannel</code>，需要一个 <code>Buffer</code> 作为参数。下面是一个示例：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
        channel.write(buf);
}
</code></pre>

<p>注意，<code>SocketChannel.write()</code> 方法是如何在 while 循环中调用的。并不保证 <code>write()</code> 方法写多少字节到 <code>SocketChannel</code> 中。因而，我们重复调用 <code>write()</code> 方法，直到 <code>Buffer</code> 中没有任何字符需要写出。</p>
<h4><a name="non-blocking-mode"></a> 9.5 非阻塞模式</h4>
<p>你可以设置 <code>SocketChannel</code> 成非阻塞模式。当你这样做时，你可以以异步模式调用 <code>connect()</code>，<code>read()</code> 和 <code>write()</code> 方法。</p>
<h5><a name="connect"></a> 9.5.1 connect()</h5>
<p>如果 <code>SocketChannel</code> 是非阻塞模式，而且你调用了 <code>connect()</code> 方法，这个方法可以在连接建立前就返回。决定连接是否建立了，你可以调用 <code>finishConnect()</code> 方法，像这样：</p>
<pre><code>socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));

while(! socketChannel.finishConnect() ){
    //wait, or do something else...
}
</code></pre>

<h5><a name="write"></a> 9.5.2 write()</h5>
<p>非阻塞模式下，<code>write()</code> 方法可能直接返回，并且没有写出任何数据。因而，你需要在循环中调用 <code>wriet()</code> 方法。但是，上面的例子已经演示了这个做法，这里没有什么不同。</p>
<h5><a name="read"></a> 9.5.3 read()</h5>
<p>非阻塞模式下，<code>read()</code> 方法可能直接返回，而且没有读到任何数据。因而，你需要注意返回的 <code>int</code> 值，告诉你读入了多少字节。</p>
<h5><a name="non-blocking-mode-with-selectors"></a> 9.5.4 非阻塞模式和 Selector</h5>
<p><code>SocketChannel</code> 的非阻塞方式搭配使用 <code>Selector</code> 将会工作的很好。通过注册一或多个 <code>SocketChannel</code> 到一个 <code>Selecotor</code>，你可以询问 <code>Selector</code> 找到处于准备状态（读，写等）的通道。如何使用 <code>Selector</code> 和 <code>SocketChannel</code> 将会在下文中详细解释。</p>
<h3><a name="Java-NIO-ServerSocketChannel"></a> 10. Java NIO ServerSocketChannel</h3>
<p>Java NIO ServerSocketChannel 是一个通道，可以监听到达的 TCP 连接，就像标准 Java 网络编程中 <a href="http://tutorials.jenkov.com/java-networking/server-sockets.html">ServerSocket</a>。<code>ServerSocketChannel</code> 类在 <code>java.nio.channels</code> 包下。</p>
<p>下面是一个例子：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));

while(true){
    SocketChannel socketChannel = serverSocketChannel.accept();

    //do something with socketChannel...
}
</code></pre>

<h4><a name="opening-a-serversocketchannel"></a> 10.1 打开 ServerSocketChannel</h4>
<p>你打开一个 <code>ServerSocketChannel</code> 通过调用 <code>ServerSocketChannel.open()</code> 方法。按照下面这样做：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
</code></pre>

<h4><a name="closing-a-serversocketchannel"></a> 10.2 关闭 ServerSocketChannel</h4>
<p>关闭一个 <code>ServerSocketChannel</code> 通过 <code>ServerSocketChannel.close()</code> 方法。按照下面这样做：</p>
<pre><code>serverSocketChannel.close();
</code></pre>

<h4><a name="listening-for-incoming-connections"></a> 10.3 监听连入连接</h4>
<p>监听连入连接通过 <code>ServerSocketChannel.accept()</code> 方法。当 <code>accept()</code> 方法返回时，它返回一个 <code>SocketChannel</code> 代表一个连入连接。因而，<code>accept()</code> 方法阻塞直到有连接到达。</p>
<p>因为你一般不会只对一个单一连接感兴趣，因而你将需要在一个 while 循环中调用 <code>accept()</code> 方法。向下面这样：</p>
<pre><code>while(true){
    SocketChannel socketChannel =
        serverSocketChannel.accept();

    //do something with socketChannel...
}
</code></pre>

<p>当然你可以在循环中使用一些停止条件而不是 <code>true</code>。</p>
<h4><a name="non-blocking-mode"></a> 10.4 非阻塞模式</h4>
<p>一个 <code>ServerSocketChannel</code> 将可以设置成非阻塞模式。非阻塞模式下，<code>accept()</code> 方法立即返回，并可能返回 null 值，如果没有任何连接连入。因而，你需要检查返回的 <code>SocketChannel</code> 是否为 null 值。下面是一个例子：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true){
    SocketChannel socketChannel =
        serverSocketChannel.accept();

    if(socketChannel != null){
    //do something with socketChannel...
    }
}
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
