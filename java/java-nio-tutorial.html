<!DOCTYPE html>
<html>
<head>
<title>java-nio-tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Java NIO</h2>
<ol>
<li><a href="#Java-NIO-Tutorial">Java NIO 教程</a></li>
<li>
<a href="#Java-NIO-Overview">Java NIO 概述</a>
<ul>
<li><a href="#channels-and-buffers">Channels 和 Buffers</a></li>
<li><a href="#selectors">Selectors</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Channel">Java NIO Channel</a>
<ul>
<li><a href="#channel-implementations">Channel 实现</a></li>
<li><a href="#basic-channel-example">基本 Channel 示例</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Buffer">Java NIO Buffer</a>
<ul>
<li><a href="#basicusage">基本 Buffer 使用</a></li>
<li>
<a href="#capacity-position-limit">Buffer 容量，位置和限制</a>
<ul>
<li><a href="#capacity">容量</a></li>
<li><a href="#position">位置</a></li>
<li><a href="#limit">限制</a></li>
</ul>
</li>
<li><a href="#buffertypes">Buffer 类型</a></li>
<li><a href="#allocating">分配 Buffer</a></li>
<li><a href="#writing">写数据到 Buffer 中</a></li>
<li><a href="#flip">flip()</a></li>
<li><a href="#reading">从 Buffer 读数据</a></li>
<li><a href="#rewind">rewind()</a></li>
<li><a href="#clear">clear() 和 compact()</a></li>
<li><a href="#mark">mark() 和 reset()</a></li>
<li>
<a href="#equals-and-compareto">equals() 和 compareTo()</a>
<ul>
<li><a href="#equals">equals()</a></li>
<li><a href="#compareTo">compareTo()</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Java-NIO-Scatter-Gather">Java NIO Scatter / Gather</a>
<ul>
<li><a href="#scattering-reads">Scattering Reads</a></li>
<li><a href="#gathering-writes">Gathering Writes</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Channel-to-Channel-Transfers">Java NIO 通道之间数据传送</a>
<ul>
<li><a href="#transferfrom">transferFrom()</a></li>
<li><a href="#transferto">transferTo()</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Selector">Java NIO Selector</a>
<ul>
<li><a href="#why-use-a-selector">为什么使用 Selector</a></li>
<li><a href="#creating-a-selector">创建 Selector</a></li>
<li><a href="#registering-channels-with-the-selector">向 Selector 注册 Channel</a></li>
<li>
<a href="#selectionkey">SelectionKey 的</a>
<ul>
<li><a href="#selector-interest-sets">兴趣位（Interest Set）</a></li>
<li><a href="#selector-ready-set">状态位（Ready Set）</a></li>
<li><a href="#channel-selector">Channel + Selector</a></li>
<li><a href="#attaching-objects">关联对象</a></li>
</ul>
</li>
<li>
<a href="#selecting-channels-via-a-selector">通过 Selector 选择 Channel</a>
<ul>
<li><a href="#selectedkeys">selectedKeys()</a></li>
</ul>
</li>
<li><a href="#wakeup">wakeUp()</a></li>
<li><a href="#close">close()</a></li>
<li><a href="#full-selector-example">完整 Selector 示例</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-FileChannel">Java NIO FileChannel</a>
<ul>
<li><a href="#opening-a-filechannel">打开 FileChannel</a></li>
<li><a href="#reading-data-from-a-filechannel">从 FileChannel 读数据</a></li>
<li><a href="#writing-data-to-a-filechannel">写数据到 FileChannel</a></li>
<li><a href="#closing-a-filechannel">关闭 FileChannel</a></li>
<li><a href="#filechannel-position">FileChannel 位置</a></li>
<li><a href="#filechannel-size">FileChannel 大小</a></li>
<li><a href="#filechannel-truncate">FileChannel 截断</a></li>
<li><a href="#filechannel-force">FileChannel 强制刷新</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-SocketChannel">Java NIO SocketChannel</a>
<ul>
<li><a href="#opening-a-socketchannel">打开 SocketChannel</a></li>
<li><a href="#closing-a-socketchannel">关闭 SocketChannel</a></li>
<li><a href="#reading-from-a-socketchannel">从 SocketChannel 读</a></li>
<li><a href="#writing-to-a-socketchannel">写向 SocketChannel</a></li>
<li>
<a href="#non-blocking-mode">非阻塞模式</a>
<ul>
<li><a href="#connect">connect()</a></li>
<li><a href="#write">write()</a></li>
<li><a href="#read">read()</a></li>
<li><a href="#non-blocking-mode-with-selectors">非阻塞模式和 Selector</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Java-NIO-ServerSocketChannel">Java NIO ServerSocketChannel</a>
<ul>
<li><a href="#opening-a-serversocketchannel">打开 ServerSocketChannel</a></li>
<li><a href="#closing-a-serversocketchannel">关闭 ServerSocketChannel</a></li>
<li><a href="#listening-for-incoming-connections">监听连入连接</a></li>
<li><a href="#non-blocking-mode">非阻塞模式</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-DatagramChannel">Java NIO DatagramChannel</a>
<ul>
<li><a href="#opening-a-datagramchannel">打开 DatagramChannel</a></li>
<li><a href="#receiving-data">接收数据</a></li>
<li><a href="#sending-data">发送数据</a></li>
<li><a href="#connecting-to-a-specific-address">连接特定地址</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Pipe">Java NIO Pipe</a>
<ul>
<li><a href="#creating-a-pipe">创建管道</a></li>
<li><a href="#writing-to-a-pipe">写向通道</a></li>
<li><a href="#reading-from-a-pipe">从通道读</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-vs-IO">Java NIO 对比 IO</a>
<ul>
<li><a href="#main-differences-between-java-nio-and-io">Java NIO 和 IO 的主要区别</a></li>
<li><a href="#stream-oriented-vs-buffer-oriented">面向流对比面向 Buffer</a></li>
<li><a href="#blocking-vs-non-blocking">阻塞对比非阻塞 IO</a></li>
<li><a href="#selectors">Selector</a></li>
<li>
<a href="#how-nio-and-io-influences-application-design">NIO 和 IO 如何影响应用设计</a>
<ul>
<li><a href="#the-api-calls">API 调用</a></li>
<li><a href="#the-processing-of-data">数据处理</a></li>
</ul>
</li>
<li><a href="#summary">总结</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Path">Java NIO Path</a>
<ul>
<li>
<a href="#creating-a-path-instance">创建 Path 实例</a>
<ul>
<li><a href="#creating-an-absolute-path">创建绝对路径</a></li>
<li><a href="#creating-a-relative-path">创建相对路径</a></li>
</ul>
</li>
<li><a href="#path-normalize">Path.normalize()</a></li>
</ul>
</li>
<li>
<a href="#Java-NIO-Files">Java NIO Files</a>
<ul>
<li><a href="#files-exists">Files.exists()</a></li>
<li><a href="#files-create-directory">Files.createDirectory()</a></li>
<li>
<a href="#files-copy">Files.copy()</a>
<ul>
<li><a href="#overwriting-existing-files">覆盖已存在文件</a></li>
</ul>
</li>
<li><a href="#files-move">Files.move()</a></li>
<li><a href="#files-delete">Files.delete()</a></li>
<li><a href="#files-additional-methods">Files 类中其他方法</a></li>
</ul>
</li>
</ol>
<h3><a name="Java-NIO-Tutorial"></a> 1. Java NIO 教程</h3>
<p>Java NIO（New IO）是 Java IO API 的替代方案（Java 1.4 之后），是指传统 <a href="http://tutorials.jenkov.com/java-io/index.html">Java IO</a> 和 <a href="http://tutorials.jenkov.com/java-networking/index.html">Java Networking</a> API 的一种替代。Java NIO 相比于传统的 IO API，提供了一种使用 IO 的不同方式。</p>
<h4>1.1 Java NIO：Channels 和 Buffers</h4>
<p>使用传统 IO API，你实际使用的是字节流和字符流。而 NIO 中，你需要使用通道和缓冲区。数据总是从通道读入到缓冲区，或从缓冲区写向通道。</p>
<h4>1.2 Java NIO：非阻塞（Non-blocking）IO</h4>
<p>Java NIO 可以使你实现非阻塞的 IO。比如，线程可以向通道请求读入数据到缓冲区。当通道在读数据到缓冲区的时候，那个线程可以执行其他操作。一旦当数据读入到缓冲区中时，线程就可以接着处理它。这同样适用于写数据到通道中。</p>
<h4>1.3 Java NIO：Selectors</h4>
<p>Java NIO 包含“Selector”的概念。Selector 是一个对象，它可以为多个通道监测特定事件（像：连接开启，数据到达等）。因而，一个简单线程就可以为数据监测多个通道。</p>
<h3><a name="Java-NIO-Overview"></a> 2. Java NIO 概述</h3>
<p>Java NIO 包含如下核心组件：</p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<p>Java NIO 当然有很多类和组件，而不止上面的 3 个，但是在我看来， <code>Channel</code>，<code>Buffer</code> 和 <code>Selector</code> 是最核心的 API。剩下的组件，像 <code>Pipe</code> 和 <code>FileLock</code> 仅仅是为了与这 3 个核心组件协作的工具类。因而，本小节，我将会重点关注于这三个组件。其他的组件会在本教程的其他小节解释到。参见本页顶的索引目录。</p>
<h4><a name="channels-and-buffers"></a> 2.1 Channels 和 Buffers</h4>
<p>一般，所有 NIO 中的 IO 都由一个 <code>Channel</code> 作为开始。<code>Channel</code> 有点类似于流。数据可以从 <code>Channel</code> 被读入到 <code>Buffer</code>。数据也可以从 <code>Buffer</code> 被写入到 <code>Channel</code>。这里是关于上述的一个图例：</p>
<p><center><img src="overview-channels-buffers.png" alt="overview-channels-buffers" /></center>
<center><strong>Java NIO：Channel 读数据到 Buffer，Buffer 写数据到 Channel。</strong></center></p>
<p>有多种 <code>Channel</code> 和 <code>Buffer</code> 类型。下面是 Java NO 中一组主要的 <code>Channel</code> 实现类：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>如你所见，这些通道覆盖了 UDP 和 TCP 网络 IO 和文件 IO。</p>
<p>有一些有趣的接口跟这些类一起工作，但是为简单起见，我不会在本节中讲述。它们将会在本教程其他章节涉及到的地方被解释。</p>
<p>下面是 Java NIO 中一组核心 <code>Buffer</code> 实现类：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 <code>Buffer</code> 涵盖了你可以通过 IO 发送的基本数据类型：byte，short，int，long，float，double，和 characters。</p>
<p>Java NIO 同样有一个 <code>MappedByteBuffer</code>，用于跟内存映射文件相协作。我也不会在本章节讨论这个 <code>Buffer</code>。</p>
<h4><a name="selectors"></a> 2.2 Selectors</h4>
<p>一个 <code>Selector</code> 允许一个简单线程处理多个 <code>Channel</code>。如果你的应用有多个连接（Channel）处于打开状态，但每个连接只有较低的流量，这将会很有利。</p>
<p>比如，一个聊天服务器。</p>
<p>下面是一个线程使用 <code>Selector</code> 处理 3 个 <code>Channel</code> 的示意图：</p>
<p><center><img src="overview-selectors.png" alt="overview-selectors" /></center>
<center><strong>一个线程使用一个 Selector 处理 3 个 Channel。</strong></center></p>
<p>为了使用 <code>Selector</code>，你需要注册 <code>Channel</code> 到它。然后你调用它的 <code>select()</code> 方法。这个方法将会一直阻塞直到某一个已注册的通道的监听事件到来。一旦这个方法返回，线程就可以处理这些事件了。事件类型比如连接到达，接收到数据等。</p>
<h3><a name="Java-NIO-Channel"></a> 3. Java NIO Channel</h3>
<p>Java NIO 通道跟流很相似，但也有一些不同：</p>
<ul>
<li>你可以同时读和写一个通道。流一般是单一的（只读或只写）。</li>
<li>通道可以被异步读写。</li>
<li>通道总是从缓冲区中读，像缓冲区写。</li>
</ul>
<p>像上面提到的，你可以从通道读数据到缓冲区，及从缓冲区写数据到通道。这里是一个示意图：</p>
<p><center><img src="overview-channels-buffers.png" alt="overview-channels-buffers" /></center>
<center><strong>Java NIO：Channel 读数据到 Buffer，Buffer 写数据到 Channel。</strong></center></p>
<h4><a name="channel-implementations"></a> 3.1 Channel 实现</h4>
<p>下面是 Java NIO 中一些最重要的 Channel 实现类：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p><code>FileChannel</code> 从文件读或写数据。</p>
<p><code>DatagramChannel</code> 可以通过 UDP 协议从网络读和写数据。</p>
<p><code>SocketChannel</code> 可以通过 TCP 协议从网络读或写数据。</p>
<p><code>ServerSocketChannel</code> 允许你监听到达的 TCP 连接，像 web 服务器那样。每一个到达的链接，就会创建一个 <code>SocketChannel</code>。</p>
<h4><a name="basic-channel-example"></a> 3.2 基本 Channel 示例</h4>
<p>下面是一个基本示例，使用 <code>FileChannel</code> 读取一些数据到 Buffer：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {

    System.out.println(&quot;Read &quot; + bytesRead);
    buf.flip();

    while (buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();
</code></pre>

<p>注意 <code>buf.flip()</code> 调用。首先你读到一个 Buffer 中。然后，你切换读写模式。然后，读出它。我将会在下一小节讲解更多关于 <code>Buffer</code> 的细节。</p>
<h3><a name="Java-NIO-Buffer"></a> 4. Java NIO Buffer</h3>
<p>Java NIO Buffer 用于跟 NIO Channel 交互。如你所知，数据从 Channel 读入 Buffer，从 Buffer 写向 Channel。</p>
<p>一个 Buffer，本质是一块内存区域，你可以写入数据到其中，并之后进行重读。这块内存区域被包装成 NIO Buffer 对象，这些对象提供了一系列方法使的更易于跟内存块一起工作。</p>
<h4><a name="basicusage"></a> 4.1 基本 Buffer 使用</h4>
<p>使用一个 Buffer 来读和写数据，一般有 4 步：</p>
<ol>
<li>写数据到 Buffer 中</li>
<li>调用 buffer.flip()</li>
<li>从 Buffer 读取读数</li>
<li>调用 buffer.clear() 或 buffer.compact()</li>
</ol>
<p>当你写数据到 Buffer 中，这个 Buffer 会记录你已经写了多少数据。一旦，你需要读数据，就需要通过 <code>flip()</code> 来切换 Buffer 从写模式到读模式。读模式下，Buffer 可以使你读到所有已写入 Buffer 的数据。</p>
<p>一旦你读完了所有数据，你需要清空 Buffer，使它可以做好准备再次写入。你可以通过两种方式实现：调用 <code>clear()</code> 或调用 <code>compant()</code>。<code>clear()</code> 方法清空整个 Buffer。<code>compact()</code> 方法仅仅清空你已经读过的数据。所有未读数据将会被移动到 Buffer 的开始位置，然后数据将会被写入到 Buffer 中未读数据的后面。</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {

    System.out.println(&quot;Read &quot; + bytesRead);
    buf.flip();

    while (buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();
</code></pre>

<h4><a name="capacity-position-limit"></a> 4.2 Buffer 容量，位置和限制</h4>
<p>下面是一个简单实用 <code>Buffer</code> 的示例，包括写，切换，读和清空操作：</p>
<p>一个 Buffer 本质上是一块内存区域，你可以写入数据到其中，并之后再次阅读。这块内存区域被包装成 NIO Buffer 对象，这些对象提供了一系列方法使的更易于跟内存块一起工作。</p>
<p>一个 Buffer 有 3 个你需要熟悉的属性，才能理解一个 <code>Buffer</code> 是如何工作的。它们是：</p>
<ul>
<li>容量（capacity）</li>
<li>位置（position）</li>
<li>限制（limit）</li>
</ul>
<p><code>position</code> 和 <code>limit</code> 的实际含义依赖于 <code>Buffer</code> 是处于读还是写模式。容量总是同一个含义，跟 Buffer 模式无关。</p>
<p>下面是容量、位置和限制在写和读模式下的示意图。示意图的解释在下一小节。</p>
<p><center><img src="buffers-modes.png" alt="buffers-modes" /></center>
<center><strong>写和读模式下 Buffer 容量，位置和限制。</strong></center></p>
<h5><a name="capacity"></a> 4.2.1 容量（capacity）</h5>
<p>一个内存块，即一个 <code>Buffer</code> 有一个确定的尺寸，也叫做它的“capacity”。你只能写 <code>catacity</code> 长度的 byte，long 和 char 等到 Buffer 中。一旦 Buffer 满了，你需要先清空它（读数据，或清空它），在你可以再次写入更多数据之前。</p>
<h5><a name="position"></a> 4.2.2 位置（position）</h5>
<p>当你写入数据到 <code>Buffer</code> 中，你会设置一个指定 position。初始化时 position 是 0。当一个 byte，long 等已经被写入到 <code>Buffer</code> 中，position 就会前进到下一个 Buffer 中的格子来插入下个数据。position 最大可以变成 <code>capacity - 1</code>。</p>
<p>当你从 <code>Buffer</code> 中读入数据时，你也同样需要根据当前 position 来设置新 position。当你切换一个 <code>Buffer</code> 从写模式到读模式时，position 将被重设成 0。当你从 <code>Buffer</code> 读入数据时，也将会变动 <code>position</code> 值，即前进 <code>position</code> 到下个被读的位置。</p>
<h5><a name="limit"></a> 4.2.3 限制（limit）</h5>
<p>写模式下，一个 <code>Buffer</code> 的 limit 是你可以写入多少数据到 Buffer 中。写模式下，limit 是等于 <code>Buffer</code> capacity 的。</p>
<p>当切换 <code>Buffer</code> 到读模式，limit 表示你可以从 Buffer 中读多少数据（译注：原文是 from the data，应该是错误的，data 应该是 buffer）。因而，当切换一个 <code>Buffer</code> 到读模式，limit 值被设置成写模式下写入数据时的最后 position。换句话说，你写了多少数据就可以读入多少数据（limit 被设置成已写字节（译注：应该是指定类型的数据）的数量，即 position 值）。</p>
<h4><a name="buffertypes"></a> 4.3 Buffer 类型</h4>
<p>Java NIO 中有以下 <strong>Buffer</strong> 类型：</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>如你所见，这些 <code>Buffer</code> 类型用于表示不同的数据类型。换句话说，它们使你可以对待 Buffer 中的字节成 char，short，int，long，float 或 double 类型。</p>
<p><code>MappedByteBuffer</code> 有点特殊，将会在自己小节中讲解。</p>
<h4><a name="allocating"></a> 4.4 分配 Buffer</h4>
<p>为了获得一个 <code>Buffer</code> 对象，你必须先分配它。每个 <code>Buffer</code> 类都有一个 <code>allocate()</code> 方法，来实现分配操作。下面是一个例子展示了对 <code>ByteBuffer</code> 的分配，容量 48 字节：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
</code></pre>

<p>下面的例子分配一个 <code>CharBuffer</code>，容量为 1024 个 char：</p>
<pre><code>CharBuffer buf = CharBuffer.allocate(1024);
</code></pre>

<h4><a name="writing"></a> 4.5 写数据到 Buffer 中</h4>
<p>你可以写数据到 <code>Buffer</code> 中，有两种方式：</p>
<ol>
<li>从 <code>Channel</code> 写数据到 <code>Buffer</code> 中。</li>
<li>直接通过 <code>Buffer</code> 写入数据，通过 Buffer 的 <code>put()</code> 方法。</li>
</ol>
<p>下面的例子展示一个 <code>Channel</code> 如何写入数据到 <code>Buffer</code> 中：</p>
<pre><code>int bytesRead = inChannel.read(buf); //read into buffer.
</code></pre>

<p>下面的例子是写入数据到 <code>Buffer</code> 中，通过 <code>put()</code> 方法：</p>
<pre><code>buf.put(127);
</code></pre>

<p>有很多其他版本的 <code>put()</code> 方法，允许你通过多种方式写数据到 <code>Buffer</code> 中。比如，在特定的位置写入数据，或写一个字节数组到 Buffer 中。具体 Buffer 实现类的细节，参见 JavaDoc。</p>
<h4><a name="flip"></a> 4.6 flip()</h4>
<p><code>flip()</code> 方法切换 <code>Buffer</code> 从写模式到读模式。调用 <code>flip()</code> 会设置 <code>position</code> 成 0，并设置 <code>limit</code> 为 position 值。</p>
<p>换句话说，<code>position</code> 现在标记读的位置，<code>limit</code> 标记多少字节，字符等被入到 Buffer 中，即多少字节，字符等可以被读出。</p>
<h4><a name="reading"></a> 4.7 从 Buffer 读数据</h4>
<p>有两种方式，你可以从 <code>Buffer</code> 读入数据。</p>
<ol>
<li>从 Buffer 读数据到一个 Channel。</li>
<li>从 Buffer 本身读取数据，通过 <code>get()</code> 方法。</li>
</ol>
<p>下面的例子展示你如何从 Buffer 读数据到一个 Channel 中：</p>
<pre><code>//read from buffer into channel.
int bytesWritten = inChannel.write(buf);
</code></pre>

<p>下面的例子展示了通过 <code>get()</code> 方法从 <code>Buffer</code> 读入数据：</p>
<pre><code>byte aByte = buf.get();
</code></pre>

<p>还有很多其他版本的 <code>get()</code> 方法，允许你从 <code>Buffer</code> 以多种方式读数据。比如，读取特定位置的数据，从 Buffer 读取一个字节数组。具体 Buffer 实现类的细节，参见 JavaDoc。</p>
<h4><a name="rewind"></a> 4.7 rewind()</h4>
<p><code>Buffer.rewind()</code> 重新设置 <code>position</code> 成 0，这样你可以重新读取 Buffer 中的所有数据。<code>limit</code> 值不会变化，即仍标记可以从 <code>Buffer</code> 读取多少元素（字节，字符等）。</p>
<h4><a name="clear"></a> 4.8 clear() 和 compact()</h4>
<p>一旦你完成了从 <code>Buffer</code> 读取数据，你必须使 <code>Buffer</code> 做好准备再次被写入。你可以通过调用 <code>clear()</code> 或 <code>compact()</code> 来做到这个。</p>
<p>如果你调用 <code>clear()</code> 方法，将会设置 <code>position</code> 成 0，<code>limit</code> 成 <code>capacity</code> 值。换句话说，<code>Buffer</code> 被清空了。<code>Buffer</code> 中的实际数据并没有被清空。这些标记变量仅仅告诉你可以从哪里写入数据到 <code>Buffer</code> 中。</p>
<p>如果 <code>Buffer</code> 中还有未被读取的数据，当你调用 <code>clear()</code> 的时候，这些数据将会被“遗忘”，即你不再有任何标记变量告诉你什么数据已经读过了，什么数据还没有被读过。</p>
<p>如果 <code>Buffer</code> 中仍有未被读取的数据，而且你还想在之后读取，但你需要首先做一些写入操作，则需要调用 <code>compact()</code> 方法而非 <code>clear()</code>。</p>
<p><code>compact()</code> 复制这些未读数据到 <code>Buffer</code> 中起始位置。然后，设置 <code>position</code> 为最右边的未读元素的索引。<code>limit</code> 值设置成 <code>capacity</code> 值，就像 <code>clear()</code> 方法所做的那样。现在，<code>Buffer</code> 已经是可以再次写入的状态了，但你并没有复写未读数据。</p>
<h4><a name="mark"></a> 4.9 mark() 和 reset()</h4>
<p>你可以在 <code>Buffer</code> 中标记一个给定的 position，通过调用 <code>Buffer.mark()</code> 方法。然后，你可以重设 position 到这个已标记的 position，通过调用 <code>Buffer.reset()</code> 方法。下面是一个例子：</p>
<pre><code>buffer.mark();
//call buffer.get() a couple of times, e.g. during parsing.
buffer.reset();  //set position back to mark.
</code></pre>

<h4><a name="equals-and-compareto"></a> 4.10 equals() 和 compareTo()</h4>
<p>可以比较两个 Buffer， 通过 <code>equals()</code> 和 <code>compareTo()</code>。</p>
<h5><a name="equals"></a> 4.10.1 equals()</h5>
<p>两个 Buffer 是相等的，如果（译注：同时满足 3 个条件）：</p>
<ol>
<li>它们具有相同的类型（字节，字符，整形等）。</li>
<li>它们的 Buffer 中有同等数量的未读（译注：此处为 remaining，翻译成“未读”？）字节，字符等。</li>
<li>所有的字节，字符等是相等的。</li>
</ol>
<p>如你所见，equals 方法仅仅比较 <code>Buffer</code> 的一部分，而非其中的每一个元素。其实，它仅比较 <code>Buffer</code> 中的未读元素。</p>
<h5><a name="compareTo"></a> 4.10.2 compareTo()</h5>
<p><code>compareTo()</code> 方法比较两个 Buffer 的剩余元素（字节，字符等），比如，排序例程。一个 Buffer “小于”另一个 Buffer 如果：</p>
<ol>
<li>Buffer 中第一个元素小于另一个 Buffer 中的相应元素。</li>
<li>所有的元素是相等的，但是第一个 Buffer 先于第二个 Buffer 读（耗）尽了所有元素（即，第一个 Buffer 有较少的元素）。</li>
</ol>
<h3><a name="Java-NIO-Scatter-Gather"></a> 5. Java NIO 散和收（Sactter/Gather）</h3>
<p>Java NIO 有内建的 scatter / gather 支持。scatter / gather 的概念用于读 / 写 channel。</p>
<p>一个 scattering 用于从 channel 执行读操作，读数据到一个或多个 buffer 中。因而，channel 用于从多个通道“分散”数据到多个缓冲区中。</p>
<p>一个 gathering 写向 channel 是一个写操作来写数据到 channel 中，可以从一或多个缓冲区中写数据到一个单一的 channel。</p>
<p>scatter / gather 会是很有用的解决方案，当你需要用分开使用多种类的数据时。比如，如果一个消息由一个头（header）和正文（body）组成，你可能想将头和正文放在分开的缓冲区中。这样做，可以使你更易于以分离的方式使用头和正文。</p>
<h4><a name="scattering-reads"></a> 5.1 分散读（Scattering Reads）</h4>
<p>一个“散开读”从一个单一通道中读数据到多个缓冲区中。下面是这个原理的实例图：</p>
<p><center><img src="scatter.png" alt="scatter" /></center>
<center><strong>Java NIO：分散读</strong></center></p>
<p>这面这个例子展示如何实现一个分散读：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);

ByteBuffer[] bufferArray = { header, body };

channel.read(buffers);
</code></pre>

<p>注意，实例化后的缓冲区先被插入到数组中的，然后数组作为参数传递到 <code>channel.read()</code> 方法。然后，<code>read()</code> 方法按照数组中缓冲区的顺序，从通道中写数据到数组中的缓冲区实例。一旦一个缓冲区写满了，通道转向下一个，并填满它。</p>
<p>分散读填满一个缓冲区之后才会转向下一个，这意味着动态大小的消息部分并不适合使用分散读。换句话说，如果你有一个头和正文，而且头有固定尺寸（如，128 字节），那么分散度将会相当有效。</p>
<h4><a name="gathering-reads"></a> 5.2 收集写（Gathering Writes）</h4>
<p>一个“收集写”从多个缓冲区中写数据到一个单一通道中。下面是这个原理的示意图：</p>
<p><center><img src="gather.png" alt="gather" /></center>
<center><strong>Java NIO：收集写</strong></center></p>
<p>下面的代码示例展示如何实现一个收集写：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);

//write data into buffers

ByteBuffer[] bufferArray = { header, body };

channel.write(buffers);
</code></pre>

<p>缓冲区数组传递到 <code>write()</code> 方法，该方法按照数组中缓冲区的顺序将内容写到通道中。仅仅在 position 和 limit 之间的缓冲区内容才会被写出。因而，如果一个缓冲区的容量为 128 字节，但仅包含 58 字节的实际数据，那么只会有这 58 字节从缓冲区写向通道中。因此，一个收集写在消息大小是动态变化时将会工作的很好，跟分散读相反。</p>
<h3><a name="Java-NIO-Channel-to-Channel-Transfers"></a> 6. Java NIO 通道之间数据传送</h3>
<p>Java NIO 中，你可以直接将数据从一个通道转到另一个通道中，如果通道中的一个是 <code>FileChannel</code> 的话。<code>FileChannel</code> 类有一个 <code>transferTo()</code> 和一个 <code>transferFrom()</code> 方法，来完成数据转送操作。</p>
<h4><a name="transferfrom"></a> 6.1 transferFrom()</h4>
<p><code>FileChannel.transferFrom()</code> 方法从一个源通道转送数据到另一个 <code>FileChannel</code>。</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel      fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel      toChannel = toFile.getChannel();

long position = 0;
long count    = fromChannel.size();

toChannel.transferFrom(fromChannel, position, count);
</code></pre>

<p>position 和 count 参数，告诉目标（被写入）文件从哪里开始写数据（<code>position</code>），及应该转送最大多大（<code>count</code>）字节的数据。如果源通道数据量少于 <code>count</code> 字节，那么将只转送能够转送的数据量。</p>
<p>另外，一些 <code>SocketChannel</code> 实现可能也可以转送数据，这些数据只是 <code>SocketChannel</code> 中当前已经在内部缓冲区中的了，即使 <code>SocketChannel</code> 中可能后续有很多的数据进来。因而，它可能无法从 <code>SocketChannel</code> 转送全部的所要求的（<code>count</code>）数据到 <code>FileChannel</code> 中。</p>
<h4><a name="transferfrom"></a> 6.2 transferto()</h4>
<p><code>transferTo()</code> 方法用于从 <code>FileChannel</code> 转数据到其它通道。下面是一个简单示例：</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel      fromChannel = fromFile.getChannel();

RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel      toChannel = toFile.getChannel();

long position = 0;
long count    = fromChannel.size();

fromChannel.transferTo(position, count, toChannel);
</code></pre>

<p>注意，这个例子跟前例非常相似。唯一真正的不同是，这个方法是在哪个 <code>FileChannel</code> 对象调用的。其它都是相同的。</p>
<p>问题是，<code>SocketChannel</code> 也提供了一个 <code>transferTo()</code> 方法。<code>SocketChannel</code> 实现可能只会从 <code>FileChannel</code> 中转送字节直到发送缓冲区满了（send buffer），然后停止（译注：挂起？）。</p>
<h3><a name="Java-NIO-Selector"></a> 7. Java NIO Selector</h3>
<p><code>Selector</code> 是 Java NIO 的一个组件，用于检查一或多个 NIO Channel，并决定通道所处的状态，如可读或可写。这样，一个单线程就可以管理多个通道，及多个网络连接。</p>
<h4><a name="why-use-a-selector"></a> 7.1 为什么使用 Selector</h4>
<p>只使用一个线程来处理多个通道的优点是你只需较少的线程来处理通道。其实，通过 <code>Selector</code>，你可以只用一个线程来处理你所有的通道。操作系统中，线程间的切换是很重的操作，而且每个线程都需要一些资源（内存等）。因而，越少的线程使用，越好。</p>
<p>但是记住，现在操作系统和 CPU 在多任务的处理上变的越来越好，所以多线程的切换代价变的越来越小。其实，如果一个 CPU 有多个核，而如果你不使用多任务的话，那你可能在浪费 CPU 的能力。不过，那种设计讨论是另外的主题。这里，只讨论通过单个线程利用 <code>Selector</code> 处理多个通道。</p>
<p>下面是一个线程利用 <code>Selector</code> 处理 3 个 <code>Channel</code> 的例子：</p>
<p><center><img src="overview-selectors.png" alt="overview-selectors" /></center>
<center><strong>一个线程使用一个 Selector 处理 3 个 Channel。</strong></center></p>
<h4><a name="creating-a-selector"></a> 7.2 创建 Selector</h4>
<p>你通过调用 <code>Selector.open()</code> 方法创建一个 <code>Selector</code>，像这样：</p>
<pre><code>Selector selector = Selector.open();
</code></pre>

<h4><a name="registering-channels-with-the-selector"></a> 7.3 向 Selector 注册 Channel</h4>
<p>为了搭配 <code>Selector</code> 使用 <code>Channel</code>，你必须注册 <code>Channel</code> 到 <code>Selector</code>。这通过 <code>SelectableChannel.register()</code> 方法实现，如下：</p>
<pre><code>channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
</code></pre>

<p><code>Channel</code> 必须处于非阻塞模式，才能搭配使用 <code>Selector</code>。这意味着，你不能为 <code>FileChannel</code> 使用 <code>Selector</code>，因为 <code>FileChannel</code> 无法切换到非阻塞模式。而 Socket 通道将会工作的很好。</p>
<p>注意 <code>register()</code> 方法的第二个参数。这是一个“兴趣位（interest set）”，表示通过 <code>Selector</code>，你为 <code>Channel</code> 设置对哪种事件感兴趣。你可以监听 4 种不同事件：</p>
<ol>
<li>连入（Connect）</li>
<li>允许（Accept）</li>
<li>读（Read）</li>
<li>写（Write）</li>
</ol>
<p>一个 <code>Channel</code> “触发一个事件（fire an event）”，也叫做“准备好（ready）”处理这个事件。所以，一个已经成功连接上另一个服务器的通道处于“连接完成状态（connect ready）”状态。一个允许接受连接的 server socket 通道，处于“接受（accept）”状态。一个有数据可以被读取的通道处于“读”状态。一个准备好向其写数据的通道处于“写”状态。</p>
<p>这 4 个状态被定义成 <code>SelectionKey</code> 的 4 个常量：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelecitonKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果，你对不止一个事件感兴趣，用“或”操作符连起它们，如：</p>
<pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre>

<p>我将会在本文下面更多的讲解“兴趣位”。</p>
<h4><a name="selectionkey"></a> 7.4 SelectionKey 的</h4>
<p>如你在前面小节中所见，当你通过 <code>register()</code> 方法注册 <code>Channel</code> 到 <code>Selector</code> 时，会返回一个 <code>SelectionKey</code> 对象。这个 <code>SelectionKey</code> 对象包括一组有意思的属性：</p>
<ul>
<li>兴趣位（interest set）</li>
<li>准备状态位（ready set）</li>
<li>通道</li>
<li>Selector</li>
<li>关联对象（可选）</li>
</ul>
<p>我将在下面描述这些属性。</p>
<h5><a name="selector-interest-sets"></a> 7.4.1 兴趣位（Interest Set）</h5>
<p>兴趣位是一组你感兴趣的事件，如在“向 Selection 注册 Channel”所描述。你可以通过 <code>SelectionKey</code> 读和写兴趣位，像这样：</p>
<pre><code>int interestSet = selectionKey.interestOps();

// 译注：&amp; 结果类型不应该是 boolean，而应该是 int。
// &amp; 结果如果是 0，表示没有注册该事件，1 表示已注册。
// 为了保持跟原文统一，我这里没有改动。
boolean isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;
</code></pre>

<p>如你所见，你可以通过“&amp;”操作符运算兴趣位和 <code>SelectionKey</code> 常量变量来查看一个确定事件是否包含在兴趣位中。</p>
<h5><a name="selector-ready-set"></a> 7.4.2 状态位（Ready Set）</h5>
<p>状态位标记一组通道预备好可以执行的操作。你将在得到 selection 后获取状态位。Selection 在下面小节中解释。你通过如下操作获取状态位：</p>
<pre><code>int readySet = selectionKey.readyOps();
</code></pre>

<p>你可以像测试兴趣位一样测试状态位（译注：通过“&amp;”操作），来确定这个通道准备好处理什么事件 / 操作。但是，你也可以使用下面 4 个便利方法，它们都将返回 boolean 值：</p>
<pre><code>selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
</code></pre>

<h5><a name="channel-selector"></a> 7.4.3 Channel + Selector</h5>
<p>从 <code>SelectionKey</code> 获取通道和 selector 很简单。按照下面操作：</p>
<pre><code>Channel  channel  = selectionKey.channel();

Selector selector = selectionKey.selector(); 
</code></pre>

<h5><a name="attaching-objects"></a> 7.4.4 关联对象</h5>
<p>你可以关联对象到一个 <code>SelectionKey</code>，这是识别给定通道的一个便利方法，或关联更多信息到通道。比如，你可以关联通道正使用的 <code>Buffer</code>，或一个包含更多聚合数据的对象。下面是如何关联对象的操作：</p>
<pre><code>selectionKey.attach(theObject);

Object attachedObj = selectionKey.attachment();
</code></pre>

<p>你也可以在向 <code>Selector</code> 注册 <code>Channel</code> 的时候就关联对象，在 <code>register()</code> 方法中。下面是示例：</p>
<pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
</code></pre>

<h4><a name="selecting-channels-via-a-selector"></a> 7.5 通过 Selector 选择通道</h4>
<p>一旦你已经注册了一或多个通道到 <code>Selector</code>，你可以调用多种 <code>select()</code> 方法中的一个。这些方法返回处于你所感兴趣的某种状态（connect，accept，read 或 write）的通道。换句话说，如果你对处于读状态的通道“感兴趣”，那么通过调用 <code>select()</code> 方法你就将获得处于读状态的通道。</p>
<p>下面是一些 <code>select()</code> 方法：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p><code>select()</code> 方法阻塞，直到至少一个通道准备好处理注册的事件（译注：处于注册的状态）。</p>
<p><code>select(long timeout)</code> 跟 <code>select()</code> 一样除了它最多阻塞 <code>timeout</code> 毫秒（参数）。</p>
<p><code>selectNow()</code> 完全不阻塞。它返回现在处于准备状态的任何通道。</p>
<p><code>select()</code> 方法的返回值是一个 <code>int</code>，告诉你多少通道处于准备状态。即，自从你上次调用过 <code>select()</code>后，多少通道处于准备状态，。如果你调用 <code>select()</code> 并返回 1，因为一个通道处于准备状态，然后多次调用 <code>select()</code>， 并且多个通道又处于准备状态，它将会再次返回 1。如果你没有用第一个准备状态的通道，你现在将会有 2 个处于准备状态的通道，但是在每次调用 <code>select()</code> 之间，只有 1 个通道变成准备状态。</p>
<h5><a name="selectedkeys"></a> 7.5.1 selectedKeys()</h5>
<p>一旦你调用了某一个 <code>select()</code> 方法，它的返回值表示一或多个通道处于准备状态，你可以通过调用 selector 的 <code>selectedKeys()</code> 方法来获得所有处于准备状态的通道。</p>
<pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
</code></pre>

<p>当你注册一个通道到 <code>Selector</code>，<code>Channel.register()</code> 方法返回一个 <code>SelectionKey</code> 对象。这个 key 表示注册到 selector 的通道。你可以通过 <code>selectedKeySet()</code> 方法得到这些 key。从 <code>SelectionKey</code> 中。（译注：<strong>不存在 selectedKeySet()</strong>。）</p>
<p>你可以遍历这些 selected key 来获得处于准备状态的通道。下面是这个的示例：</p>
<pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();

Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
}
</code></pre>

<p>这个循环遍历 selected key 集中的 key。对每一个 key，它测试这个 key 来决定 key 指向的通道所处的状态。</p>
<p>注意每次遍历最后的 <code>keyIterator.remove()</code> 方法。<code>Selector</code> 不会自己从 selected key 集中移除 <code>SelectionKey</code> 实例。当你完成对通道的处理，你需要移除。下次通道变成准备状态时，<code>Selecotr</code> 将会再次将它添加到 selected key 集中。</p>
<p><code>SelectionKey.channel()</code> 方法返回的通道需要被转型成你真正要用的通道，比如一个 <code>ServerSockterChannel</code> 或 <code>SocketChannel</code> 等。</p>
<h4><a name="wakeup"></a> 7.6 wakeUp()</h4>
<p>一个调用了 <code>select()</code> 方法而已经阻塞的线程，也可以从 <code>select()</code> 方法返回，即使没有任何通道处于准备状态。这是由一个不同的线程调用 <code>Selector</code> 上的 <code>Selector.wakeup()</code> 方法，这个 <code>Selector</code> 要和第一个调用 <code>select()</code> 的线程上的 <code>Selector</code> 是同一个。这个在内部等待 <code>select()</code> 的线程将会立即返回。</p>
<p>如果一个不同线程调用 <code>wakeup()</code>，而且没有任何线程当前内部处于 <code>select()</code> 阻塞状态，下一个调用 <code>select()</code> 的线程将会立即“唤醒”。</p>
<h4><a name="close"></a> 7.7 close()</h4>
<p>当你使用完成了 <code>Selector</code>，你需要调用它的 <code>close()</code> 方法。这将会关闭 <code>Selector</code> 并且移除所有注册到 <code>Selector</code> 的 <code>SelectionKey</code> 的实例。通道并没有关闭。</p>
<h4><a name="full-selector-example"></a> 7.8 完整 Selector 示例</h4>
<p>下面是一个完整示例，打开一个 <code>Selector</code>，注册通道（通道实例化没有包括在本例中），并且检测 <code>Selector</code> 的 4 种状态（accept，connect，read，write）。</p>
<pre><code>Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);


while(true) {

    int readyChannels = selector.select();

    if(readyChannels == 0) continue;


    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();

    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();

    while(keyIterator.hasNext()) {

        SelectionKey key = keyIterator.next();

        if(key.isAcceptable()) {
            // a connection was accepted by a ServerSocketChannel.

        } else if (key.isConnectable()) {
            // a connection was established with a remote server.

        } else if (key.isReadable()) {
            // a channel is ready for reading

        } else if (key.isWritable()) {
            // a channel is ready for writing
        }

        keyIterator.remove();
    }
}
</code></pre>

<h3><a name="Java-NIO-FileChannel"></a> 8. Java NIO FileChannel</h3>
<p>Java NIO FileChannel 是一个通道用于连接到文件。使用文件通道，你可以从文件读取数据，并向文件写数据。Java NIO FileChannel 类是 NIO 的对 <a href="#http://tutorials.jenkov.com/java-io/file.html">利用标准 Java IO API 读文件</a>的一个替代。</p>
<p><code>FileChannel</code> 无法设置成非阻塞模式。它总是运行在阻塞模式中。</p>
<h4><a name="opening-a-filechannel"></a> 8.1 打开 FileChannel</h4>
<p>在你使用 <code>FileChannel</code> 之前，你必须打开它。你不能直接打开一个 <code>FileChannel</code>。你需要从输入流（InputStream），输出流（OutputStream），或 RandomAccessFile 中获取 FileChannel。下面是如何通过 RndomAccessFile 打开 FileChannel。</p>
<pre><code>RandomAccessFile aFile     = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel      inChannel = aFile.getChannel();
</code></pre>

<h4><a name="reading-data-from-a-filechannel"></a> 8.2 从 FileChannel 读数据</h4>
<p>你可以调用 <code>read()</code> 从 <code>FileChannel</code> 读数据。下面是一个示例：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
</code></pre>

<p>首先，分配一个 <code>Buffer</code>。从 <code>FileChannel</code> 读数据到 <code>Buffer</code> 中。</p>
<p>然后，<code>FileChannel.read()</code> 方法被调用。这个方法从 <code>FileChannel</code> 读数据到 <code>Buffer</code> 中。<code>read()</code> 方法返回 <code>int</code> 值，告诉你写到 <code>Buffer</code> 中了多少字节。如果返回的是 -1，那么表示到达了文件结尾。</p>
<h4><a name="writing-data-to-a-filechannel"></a> 8.3 写数据到 FileChannel</h4>
<p>通过 <code>FileChannel.write()</code> 方法，可以写数据到 <code>FileChannel</code> 中，它需要 <code>Buffer</code> 作为参数。下面是一个示例：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
        channel.write(buf);
}
</code></pre>

<p>注意如何在 while 循环中调用 <code>FileChannel.write()</code> 方法。并不保证 <code>write()</code> 方法写多少字节到 <code>FileChannel</code> 中。因而，我们重复调用 <code>write()</code> 方法直到 <code>Buffer</code> 中没有能写出的字符。</p>
<h4><a name="closing-a-filechannel"></a> 8.4 关闭 FileChannel</h4>
<p>当你用过 <code>FileChannel</code> 之后，你必须关闭它。如下操作：</p>
<pre><code>channel.close(); 
</code></pre>

<h4><a name="filechannel-position"></a> 8.5 FileChannel 位置</h4>
<p>当读或写一个 <code>FileChannel</code> 时，你是在一个指定位置操作的。通过调用 <code>position()</code> 方法，你可以获得 <code>FileChannel</code> 对象的当前位置。</p>
<p>你也可以通过调用 <code>position(long pos)</code> 方法设置 <code>FileChannel</code> 的位置信息。</p>
<p>下面是两个例子：</p>
<pre><code>long pos = channel.position();

channel.position(pos +123);
</code></pre>

<p>如果你设置位置在文件末尾，并尝试从通道中读取数据，你将会得到 -1，标记文件结尾。</p>
<p>如果你设置位置在文件末尾，并向通道中写数据，文件将会先扩容到这个位置然后写入数据。这可能导致“文件空洞（file hole）”，即写入数据到磁盘上的物理文件有空隙。</p>
<h4><a name="filechannel-size"></a> 8.6 FileChannel 大小</h4>
<p><code>FileChannel</code> 对象的 <code>size()</code> 方法返回文件通道连接的文件的大小。</p>
<pre><code>long fileSize = channel.size();
</code></pre>

<h4><a name="filechannel-truncate"></a> 8.7 FileChannel 截断</h4>
<p>你可以截断一个文件通过 <code>FileChannel.truncate()</code> 方法。当你截断一个文件时，你切断文件成给定的长度。下面是一个示例：</p>
<pre><code>channel.truncate(1024);
</code></pre>

<p>这个例子截断文件成 1024 字节。</p>
<h4><a name="filechannel-force"></a> 8.8 FileChannel 强制刷新</h4>
<p><code>FileChannel.force()</code> 方法刷新所有通道中的未写数据到磁盘上。操作系统出于性能原因可能会在内存中缓存数据，所以无法保证数据写到通道中就是实际就写到磁盘中了，直到你调用 <code>force()</code> 方法。</p>
<p><code>force()</code> 方法需要一个 boolean 参数，表示是否将文件元数据（权限等）也同样刷新到文件中。</p>
<p>下面是一个例子，同时刷新文件数据和文件元数据。</p>
<pre><code>channel.force(true);
</code></pre>

<h3><a name="Java-NIO-SocketChannel"></a> 9. Java NIO SocketChannel</h3>
<p>Java NIO SocketChannel 是一个连接 TCP 网络端口的通道。它是 Java NIO 中的对 <a href="http://tutorials.jenkov.com/java-networking/sockets.html">Java 网络编程 Socket</a> 的替代。有两种创建 <code>SocketChannel</code> 的方式：</p>
<ol>
<li>你打开一个 <code>SocketChannel</code> 并连到一个网络上的服务器。</li>
<li>一个 <code>SocketChannel</code> 将会被创建，当一个连接到达 <a href="#Java-NIO-ServerSocketChannel">ServerSocketChannel</a> 时。</li>
</ol>
<h4><a name="opening-a-socketchannel"></a> 9.1 打开 SocketChannel</h4>
<p>下面是如何打开一个 <code>SocketChannel</code>：</p>
<pre><code>SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));
</code></pre>

<h4><a name="closing-a-socketchannel"></a> 9.2 关闭 SocketChannel</h4>
<p>你通过调用 <code>SocketChannel.close()</code> 方法来关闭一个 <code>SocketChannel</code>。下面是一个示例：</p>
<pre><code>socketChannel.close();
</code></pre>

<h4><a name="reading-from-a-socketchannel"></a> 9.3 从 SocketChannel 读</h4>
<p>通过 <code>read()</code> 方法从 <code>SocketChannel</code> 读数据。下面是一个例子：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = socketChannel.read(buf);
</code></pre>

<p>首先，一个 <code>Buffer</code> 被分配创建。然后将从 <code>SocketChannel</code> 读数据到 <code>Buffer</code> 中。</p>
<p>然后，调用 <code>SocketChannel.read()</code> 方法。这个方法从 <code>SocketChannel</code> 读数据到 <code>Buffer</code> 中。<code>read()</code> 方法返回一个 <code>int</code> 值，告诉多少字节数据被写到 <code>Buffer</code> 中。如果返回的是 -1，表示到达了流的结尾（连接关闭）。</p>
<h4><a name="writing-to-a-socketchannel"></a> 9.4 写向 SocketChannel</h4>
<p>使用 <code>SocketChannel.write()</code> 方法写数据到 <code>SocketChannel</code>，需要一个 <code>Buffer</code> 作为参数。下面是一个示例：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
        channel.write(buf);
}
</code></pre>

<p>注意，<code>SocketChannel.write()</code> 方法是如何在 while 循环中调用的。并不保证 <code>write()</code> 方法写多少字节到 <code>SocketChannel</code> 中。因而，我们重复调用 <code>write()</code> 方法，直到 <code>Buffer</code> 中没有任何字符需要写出。</p>
<h4><a name="non-blocking-mode"></a> 9.5 非阻塞模式</h4>
<p>你可以设置 <code>SocketChannel</code> 成非阻塞模式。当你这样做时，你可以以异步模式调用 <code>connect()</code>，<code>read()</code> 和 <code>write()</code> 方法。</p>
<h5><a name="connect"></a> 9.5.1 connect()</h5>
<p>如果 <code>SocketChannel</code> 是非阻塞模式，而且你调用了 <code>connect()</code> 方法，这个方法可以在连接建立前就返回。决定连接是否建立了，你可以调用 <code>finishConnect()</code> 方法，像这样：</p>
<pre><code>socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));

while(! socketChannel.finishConnect() ){
    //wait, or do something else...
}
</code></pre>

<h5><a name="write"></a> 9.5.2 write()</h5>
<p>非阻塞模式下，<code>write()</code> 方法可能直接返回，并且没有写出任何数据。因而，你需要在循环中调用 <code>wriet()</code> 方法。上面的例子已经演示了这个做法，这里没有什么不同。</p>
<h5><a name="read"></a> 9.5.3 read()</h5>
<p>非阻塞模式下，<code>read()</code> 方法可能直接返回，而且没有读到任何数据。因而，你需要注意返回的 <code>int</code> 值，告诉你读入了多少字节。</p>
<h5><a name="non-blocking-mode-with-selectors"></a> 9.5.4 非阻塞模式和 Selector</h5>
<p><code>SocketChannel</code> 的非阻塞方式搭配使用 <code>Selector</code> 将会工作的很好（译注：<strong>否则就不要使用非阻塞模式</strong>）。通过注册一或多个 <code>SocketChannel</code> 到一个 <code>Selecotor</code>，你可以询问 <code>Selector</code> 找到处于期望准备状态（读，写等）的通道。如何使用 <code>Selector</code> 和 <code>SocketChannel</code> 将会在下文中详细解释。</p>
<h3><a name="Java-NIO-ServerSocketChannel"></a> 10. Java NIO ServerSocketChannel</h3>
<p>Java NIO ServerSocketChannel 是一个通道，可以监听到达的 TCP 连接，就像标准 Java 网络编程中 <a href="http://tutorials.jenkov.com/java-networking/server-sockets.html">ServerSocket</a>。<code>ServerSocketChannel</code> 类在 <code>java.nio.channels</code> 包下。</p>
<p>下面是一个例子：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));

while(true){
    SocketChannel socketChannel = serverSocketChannel.accept();

    //do something with socketChannel...
}
</code></pre>

<h4><a name="opening-a-serversocketchannel"></a> 10.1 打开 ServerSocketChannel</h4>
<p>你打开一个 <code>ServerSocketChannel</code> 通过调用 <code>ServerSocketChannel.open()</code> 方法。按照下面这样做：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
</code></pre>

<h4><a name="closing-a-serversocketchannel"></a> 10.2 关闭 ServerSocketChannel</h4>
<p>关闭一个 <code>ServerSocketChannel</code> 通过 <code>ServerSocketChannel.close()</code> 方法。按照下面这样做：</p>
<pre><code>serverSocketChannel.close();
</code></pre>

<h4><a name="listening-for-incoming-connections"></a> 10.3 监听连入连接</h4>
<p>监听连入连接通过 <code>ServerSocketChannel.accept()</code> 方法。当 <code>accept()</code> 方法返回时，它返回一个 <code>SocketChannel</code> 代表一个连入连接。因而，<code>accept()</code> 方法阻塞直到有连接到达。</p>
<p>因为你一般不会只对一个单一连接感兴趣，因而你将需要在一个 while 循环中调用 <code>accept()</code> 方法。向下面这样：</p>
<pre><code>while(true){
    SocketChannel socketChannel =
        serverSocketChannel.accept();

    //do something with socketChannel...
}
</code></pre>

<p>当然你可以在循环中使用一些停止条件而不是 <code>true</code>。</p>
<h4><a name="non-blocking-mode"></a> 10.4 非阻塞模式</h4>
<p>一个 <code>ServerSocketChannel</code> 将可以设置成非阻塞模式。非阻塞模式下，<code>accept()</code> 方法立即返回，并可能返回 null 值，当没有任何连接连入时。因而，你需要检查返回的 <code>SocketChannel</code> 是否为 null 值。下面是一个例子：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);

while(true){
    SocketChannel socketChannel =
        serverSocketChannel.accept();

    if(socketChannel != null){
    //do something with socketChannel...
    }
}
</code></pre>

<h3><a name="Java-NIO-DatagramChannel"></a> 11. Java NIO DatagramChannel</h3>
<p>Java NIO DatagramChannel 是一个可以发送和接收 UDP 包的通道。因为 UDP 是一个无连接的网络协议，你不能像传统通道方式那样读和写到一个 <code>DatagramChannel</code>。你需要发送和接收数据包作为替代。</p>
<h4><a name="opening-a-datagramchannel"></a> 11.1 接收数据</h4>
<p>下面是你如何打开一个 <code>DatagramChannel</code>：</p>
<pre><code>DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9999));
</code></pre>

<p>这个例子打开一个 <code>DatagramChannel</code>，可以从 9999 端口接收数据包。</p>
<h4><a name="receiving-data"></a> 11.2 接收数据</h4>
<p>通过调用 <code>receivew()</code> 方法，从 <code>DatagramChannel</code> 接收数据，像这样：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();

channel.receive(buf);
</code></pre>

<p><code>receive()</code> 方法将会复制接收到得数据包到给定的 <code>Buffer</code> 中。如果，接收到的数据包中的数据多于 <code>Buffer</code> 的容量，剩下的数据将会默认丢弃。</p>
<h4><a name="sending-data"></a> 11.3 发送数据</h4>
<p>你可以通过 <code>DatagramChannel</code> 的 <code>send()</code> 方法发送数据。像这样：</p>
<pre><code>String newData = &quot;New String to write to file...&quot;
    + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();

int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));
</code></pre>

<p>这个例子发送字符串到“jenkov.com”服务器，通过 UDP 协议，在 80 端口。由于没有监听那个端口，所以什么也不会发生。你不会被通知数据包是否被接收到，因为 UDP 不保证任何数据的分发。</p>
<h4><a name="connecting-to-a-specific-address"></a> 11.4 连接特定地址</h4>
<p>可以连接 <code>DatagramChannel</code> 到一个特定的网络地址。因为 UDP 是无连接的，连接到某个网络地址不会实际创建一个真正的链接，像 TCP 通道那样。而且，它将会锁住你的 <code>DatagramChannel</code>，所以你仅能从一个特定地址发送和接收数据包。</p>
<p>下面是一个例子：</p>
<pre><code>channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));
</code></pre>

<p>当连接建立，你可以使用 <code>read()</code> 和 <code>write()</code> 方法，就像使用一个传统通道。你只是没有数据发送的保证机制。下面是一个例子：</p>
<pre><code>int bytesRead = channel.read(buf);

int bytesWritten = channel.write(buf);
</code></pre>

<h3><a name="Java-NIO-Pipe"></a> 12. Java NIO 管道</h3>
<p>Java NIO 管道是两个线程间单向的数据连接。<code>Pipe</code> 有一个源通道和一个槽通道。你写数据到槽通道。数据然后可以从源通道读取。</p>
<p>下面是 <code>Pipe</code> 原理的示意图：</p>
<p><center><img src="pipe-internals.png" alt="pipe-internals" /></center>
<center><strong>Java NIO：管道内部实现。</strong></center></p>
<h4><a name="creating-a-pipe"></a> 12.1 创建管道</h4>
<p>你通过调用 <code>Pipe.open()</code> 方法打开 <code>Pipe</code>。下面是这个例子：</p>
<pre><code>Pipe pipe = Pipe.open();
</code></pre>

<h4><a name="writing-to-a-pipe"></a> 12.2 写向通道</h4>
<p>写数据到 <code>Pipe</code> 中，你需要访问槽通道。下面是这个例子：</p>
<pre><code>Pipe.SinkChannel sinkChannel = pipe.sink();
</code></pre>

<p>你通过调用它的 <code>write()</code> 方法写向一个 <code>SinkChannel</code>，像这样：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
    sinkChannel.write(buf);
}
</code></pre>

<h4><a name="reading-from-a-pipe"></a> 12.3 从通道读</h4>
<p>从 <code>Pipe</code> 读数据，你需要访问源通道。下面是这个例子：</p>
<pre><code>Pipe.SourceChannel sourceChannel = pipe.source();
</code></pre>

<p>为了从源通道中读数据你需要调用 <code>read()</code> 方法，像这样：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
</code></pre>

<p><code>read()</code> 方法的返回值告诉你读了多少字节到缓冲区中。</p>
<h3><a name="Java-NIO-vs-IO"></a> 13. Java NIO 对比 IO</h3>
<p>我们同时学习了 Java NIO 和 IO API，那么就有一个问题：</p>
<p>什么时候使用 IO，什么时候使用 NIO 呢？</p>
<p>这一节中，我试图指出一些 Java NIO 和 IO 中的不同之处，包括，它们的使用场景，和它们如何影响你代码的设计。</p>
<h4><a name="main-differences-between-java-nio-and-io"></a> 13.1 Java NIO 和 IO 的主要区别</h4>
<p>下表总结了 Java NIO 和 IO 间的主要区别。我将会在后面小节讨论更多关于表中不同之处的细节。</p>
<table>
  <tr><th>IO</th><th>NIO</th></tr>
  <tr><td>面向流</td><td>面向缓冲区</td></tr>
  <tr><td>阻塞 IO</td><td>非阻塞 IO</td></tr>
  <tr><td></td><td>Selector</td></tr>
</table>
<h4><a name="stream-oriented-vs-buffer-oriented"></a> 13.2 面向流对比面向 Buffer</h4>
<p>Java NIO 和 IO 之间的第一个不同之处是，IO 是面向流的，而 NIO 是面向缓冲区的。所以，这是什么意思呢？</p>
<p>Java IO 是面向流的，意味着你从流中在某一时刻读入多个字节。你利用读入的字节做什么完全取决与你。它们不会再任何地方缓存。而且，你无法在流数据中向前或向后移动。如果你需要在读入的数据中向前或向后移动，你需要先在缓冲区中进行缓存。</p>
<p>Java NIO 是面向缓冲区的，有一点不同。数据被读到缓冲区中，然后再后续处理。你可以在缓冲区中前后移动，如果你需要的话。这将带给你更大的灵活性，在处理数据的时候。然而，你也需要检查缓冲中是否包含了所有你需要的数据，为了能完全的处理它。并且，你需要确保当读数据到缓冲区时，你不会覆盖你还没有处理的数据。</p>
<h4><a name="blocking-vs-non-blocking"></a> 13.3 阻塞对比非阻塞 IO</h4>
<p>Java IO 的多种流都是阻塞的。这意味着，当一个线程调用 <code>read()</code> 和 <code>write()</code> 方法，线程将会阻塞直到有可以被读的数据，或数据被全部写出。这个线程此时将什么也做不了。</p>
<p>Java NIO 的非阻塞模式使一个线程从通道请求读数据，并且只获得当前可获得的数据，或什么也无法得到，如果没有数据可被获取。相比于阻塞直到数据可以被读取，线程将会继续处理其他事情。</p>
<p>非阻塞的写也是同样的。一个线程请求一些数据写入到通道中，但是不会等待知道数据全部被写出。线程可以继续执行，并同时执行其他操作。</p>
<p>当非阻塞的 IO 调用时，线程将它们的空闲时间通常是花在处理其它通道的 IO 操作。即，一个单线程现在可以管理多个通道的输入和输出。</p>
<h4><a name="selectors"></a> 13.4 Selector</h4>
<p>Java NIO 的 Selector 允许一个单线程检测多个通道的输入。你可以注册多个通道到一个 selector，然后使用单个线程来“选择”有可读数据被处理的通道，或选择准备好写的通道。这个 selector 机制使得单个线程可以很简单的管理多个通道。</p>
<h4><a name="how-nio-and-io-influences-application-design"></a> 13.5 NIO 和 IO 如何影响应用设计</h4>
<p>无论你选择 NIO 还是 IO 作为你的 IO 工具箱，你的应用设计的下面几个方面可能会收到影响：</p>
<ol>
<li>NIO 和 IO 类的 API 调用。</li>
<li>数据处理过程。</li>
<li>用于处理数据的线程数量。</li>
</ol>
<h5><a name="the-api-calls"></a> 13.5.1 API 调用</h5>
<p>当然，你使用 NIO 的 API 肯定有别于传统 IO。这没什么可奇怪的。相比于传统 IO 只从字节流中读数据字节，如，一个 <code>InputStream</code>，NIO 中，数据必须首先被读到缓冲区中，然后从缓冲区中被处理。</p>
<h5><a name="the-processing-of-data"></a> 13.5.2 数据处理</h5>
<p>数据的处理过程同样受到影响，取决于你利用纯 NIO 设计，还是传统 IO 设计。</p>
<p>传统 IO 设计中，你从 <code>InputStream</code> 或 <code>Reader</code> 中读数据字节。假设，你正处理一个基于行的文本数据流。比如：</p>
<pre><code>Name: Anna
Age: 25
Email: anna@mailserver.com
Phone: 1234567890
</code></pre>

<p>文本行流的处理过程会像这样：</p>
<pre><code>InputStream input = ... ; // get the InputStream from the client socket

BufferedReader reader = new BufferedReader(new InputStreamReader(input));

String nameLine   = reader.readLine();
String ageLine    = reader.readLine();
String emailLine  = reader.readLine();
String phoneLine  = reader.readLine();
</code></pre>

<p>注意，处理状态的决定取决于程序执行了多远。换句话说，一旦第一个 <code>reader.readLine()</code> 方法返回，你知道你已经读入了完整的一行文本。<code>readLine()</code> 将会阻塞直到读完了一整行，这就是它一定会返回一整行文本的原因。你同样知道这一行包含了姓名。类似地，第二个 <code>readLine()</code> 调用返回，你知道这一行包含年龄等。</p>
<p>如你所见，程序持续处理仅当有新数据可以被读的时候，而且对于每一步你知道那个数据是什么。一旦，执行线程需要处理本文中已经读过的一段数据，线程是无法倒退去处理的（通常也没有这种需要）。这个原理参见下面的示意图：</p>
<p><center><img src="nio-vs-io-1.png" alt="nio-vs-io-1" /></center>
<center><strong>Java NIO：从阻塞流中读数据。</strong></center></p>
<p>NIO 实现则看起来很不同。下面是一个简单示例：</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buffer);
</code></pre>

<p>注意第二行，它从通道中读字节到 <code>ByteBuffer</code> 中。当那个方法调用返回时，你并不知道是否所有你需要的数据都已经在缓冲区中了。所有你知道的就是缓冲区中包含一些字节。这会使得处理过程变得难一点儿。</p>
<p>想象一下，第一次 <code>read(buffer)</code> 调用之后，所有读入到缓冲区中的内容只是行的一半。比如，“Name: An”。你能处理那个数据吗？并不能。你需要等待直到至少一行数据被读入到缓冲区中，在使处理任何数据变得有意义之前。</p>
<p>所以，你如何知道是否缓冲区中包含足够的内容来被处理？其实，你不知道。知道的唯一方式，就是查看缓冲区的数据。结果就是，你可能需要多次检查缓冲区的数据，在你知道所有数据都在里面之前。这既是低效的，并且也可以使程序设计变得混乱。比如：</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buffer);

while(! bufferFull(bytesRead) ) {
    bytesRead = inChannel.read(buffer);
}
</code></pre>

<p><code>bufferFull()</code> 方法需要追踪已经读了多少数据到缓冲区中，并返回 <code>true</code> 或 <code>false</code>，取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，它被认为已满。</p>
<p><code>bufferFull()</code> 方法扫描整个缓冲区，但是必须保证离开缓冲区的时候状态跟调用 <code>bufferFull()</code> 方法之前是一致的。如果不是，下一个读到缓冲区中的数据可能会在不正确的位置。这虽然是不可能的，但它是另一个需要注意的问题。</p>
<p>如果缓冲区满了，它就能被处理。如果还没满，你可以处理其中的部分数据，如果那适用于你的特定情。许多情况下，它都不会满。</p>
<p>缓冲区数据是否完备的循环示意图如下：</p>
<p><center><img src="nio-vs-io-2.png" alt="nio-vs-io-2" /></center>
<center><strong>Java NIO：持续从通道中读数据直到需要的数据在缓冲区中。</strong></center></p>
<h5><a name="summary"></a> 13.6 总结</h5>
<p>NIO 允许你管理多个通道（网络连接或文件），只使用一个（或几个）线程，但是代价是数据的处理过程可能更加复杂相比于从阻塞流中读数据。</p>
<p>如果你需要同时管理上千个连接，每个连接只发送很少的数据，比如，一个聊天服务器，以 NIO 来实现这个服务器可能更加有利。类似地，如果你需要保持许多已打开到对其它电脑的连接，如，P2P 网络，使用一个单线程来管理所有连出的连接可能是一个优势。</p>
<p>单个线程，多个连接的设计示意图如下：</p>
<p><center><img src="nio-vs-io-3.png" alt="nio-vs-io-3" /></center>
<center><strong>Java NIO：单个线程管理多个连接。</strong></center></p>
<p>如果你有一些占用很高带宽的连接，某一时刻发送大量的数据，那么可能传统的 IO 服务器实现更加适合。下面的示意图展示了传统 IO 服务器设计：</p>
<p><center><img src="nio-vs-io-4.png" alt="nio-vs-io-4" /></center>
<center><strong>Java IO：一个传统 IO 服务器 - 一个线程处理一个连接。</strong></center></p>
<h3><a name="Java-NIO-Path"></a> 14. Java NIO Path</h3>
<p>Java <code>Path</code> 接口是 Java NIO 2 的一部分，，，。Java <code>Path</code> 接口在 Java 7 中被添加到 Java NIO 中。<code>Path</code> 接口的位置在 <code>java.nio.file</code> 包下，所以 Java <code>Path</code> 接口的全名是 <code>java.nio.file.Path</code>。</p>
<p>Java <code>Path</code> 实例表示文件系统上的一个<em>路径</em>。路径可以指向文件或目录。路径可以是绝对或相对的。绝对路径包含从文件系统根路径到文件或目录的全路径。相对路径包含从某个路径开始指向文件或目录的路径。相对路径听起来有点迷惑人。不用担心。我会在本节中详细的解释它。</p>
<p>不要将“文件系统路径”弄混成一些操作系统的 <code>path</code> 环境变量。<code>java.nio.file.Path</code> 接口跟 <code>path</code> 环境变量毫无关系。</p>
<p>许多情况下，<code>java.nio.file.Path</code> 接口类似于 <a href="#http://tutorials.jenkov.com/java-io/file.html"><code>java.io.File</code></a> 类，但有一些小差别。许多场景下，你可以使用 <code>Path</code> 替换 <code>File</code> 类。</p>
<h4><a name="creating-a-path-instance"></a> 14.1 创建 Path 实例</h4>
<p>为了使用 <code>java.nio.file.Path</code> 实例，你必须创建 <code>Path</code> 实例。你通过 <code>Paths</code> 类（<code>java.nio.file.Paths</code>）的静态方法（<code>Paths.get()</code>）创建 <code>Path</code> 实例。下面是 <code>Paths.get()</code> 示例：</p>
<pre><code>import java.nio.file.Path;
import java.nio.file.Paths;

public class PathExample {

    public static void main(String[] args) {

        Path path = Paths.get(&quot;c:\\data\\myfile.txt&quot;);

    }
}
</code></pre>

<p>注意例子上面有两个 <code>import</code> 语句。为了使用 <code>Path</code> 接口和 <code>Paths</code> 类，我们必须首先导入它们。</p>
<p>然后，注意 <code>Paths.get(&quot;c:\\data\\myfile.txt&quot;)</code> 方法调用。换句话说，<code>Paths.get()</code> 方法是一个工厂方法来创建 <code>Path</code> 实例。</p>
<h5><a name="creating-an-absolute-path"></a> 14.1.1 创建绝对路径</h5>
<p>通过 <code>Paths.get()</code> 工厂方法，并将文件绝对路径作为参数来创建绝对路径。</p>
<p>下面是一个创建 <code>Path</code> 实例的例子，表示一个绝对路径：</p>
<pre><code>Path path = Paths.get(&quot;c:\\data\\myfile.txt&quot;);
</code></pre>

<p>绝对路径是 <code>c:\data\myfile.txt</code>。两个 <code>\</code>  符号在 Java 字符串中时必须的，因为 <code>\</code> 是一个转义符，意味着下一个字符才是真正要用的字符。通过写 <code>\\</code>，你告诉 Java 编译器写单个 <code>\</code> 到字符串中。</p>
<p>上面的路径是一个 Windows 文件系统路径。类 Unix 系统上（Linux，MacOS，FreeBSD 等），上面的路径看起来或是这样：</p>
<pre><code>Path path = Paths.get(&quot;/home/jakobjenkov/myfile.txt&quot;);
</code></pre>

<p>绝对路径现在是 <code>/home/jakobjenkov/myfile.txt</code>。</p>
<p>如果你在 Windows 机器上使用这种路径（以 <code>/</code> 作为起始），路径将会被解释成相对与当前磁盘的路径。比如，路径：</p>
<pre><code>/home/jakobjenkov/myfile.txt
</code></pre>

<p>将会被解释成位于 C 盘下。然后这个路径对应的全路径就是：</p>
<pre><code>C:/home/jakobjenkov/myfile.txt
</code></pre>

<h5><a name="creating-a-relative-path"></a> 14.1.2 创建相对路径</h5>
<p>相对路径是从某个路径（基本路径）开始的，指向某一个目录或文件。相对路径的全路径（绝对路径）由基本路径和相对路径派生而成。</p>
<p>Java NIO <code>Path</code> 类也可以搭配相对路径。你通过 <code>Paths.get(basePath, relativePath)</code> 方法创建相对路径。下面是 Java 中两个相对路径的例子：</p>
<pre><code>Path projects = Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;);

Path file     = Paths.get(&quot;d:\\data&quot;, &quot;projects\\a-project\\myfile.txt&quot;);
</code></pre>

<p>第一个例子创建 Java <code>Path</code> 实例，指向路径（目录）<code>d:\data\projects</code>。第二个例子创建 <code>Path</code> 实例，指向路径（文件）<code>d:\data\projects\a-project\myfile.txt</code>。</p>
<p>当使用相对路径时，有两个特殊的代码你可以在路径字符串中使用。它们是：</p>
<ul>
<li>.</li>
<li>..</li>
</ul>
<p><code>.</code> 表示“当前目录”。比如，你如果你像这样创建相对路径：</p>
<pre><code>Path currentDir = Paths.get(&quot;.&quot;);
System.out.println(currentDir.toAbsolutePath());
</code></pre>

<p>Java <code>Path</code> 实例实际关联到的绝对路径将会是上面代码执行的位置。</p>
<p>如果 <code>.</code> 在路径字符串的中间使用，就意味着它指向的是同样的目录。下面是演示这种情况的 <code>Path</code> 例子：</p>
<pre><code>Path currentDir = Paths.get(&quot;d:\\data\\projects\.\a-project&quot;);
</code></pre>

<p>这个路径会关联到：
	d:\data\projects\a-project</p>
<p><code>..</code> 表示“父目录”或“上一层目录”。下面的 <code>Path</code> 例子示例它的含义：</p>
<pre><code>Path parentDir = Paths.get(&quot;..&quot;);
</code></pre>

<p>这个例子创建的 <code>Path</code> 实例将会关联到这个目录（应用程序运行所在的目录）的父级目录。</p>
<p>如果你在路径字符串之间使用 <code>..</code>，它将会在那个位置关联到上级目录。比如：</p>
<pre><code>String path = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;
Path parentDir2 = Paths.get(path);
</code></pre>

<p>这个例子中创建的 <code>Path</code> 实例将会指向这个绝对路径：</p>
<pre><code>d:\data\projects\another-project
</code></pre>

<p><code>a-project</code> 之后的 <code>..</code> 改变目录成父目录 <code>projects</code>，并从那里指向到 <code>another-project</code> 目录。</p>
<p><code>.</code> 和 <code>..</code> 同样可以在 <code>Paths.get()</code> 方法的第二个字符串参数中使用。下面是两个 <code>Paths.get()</code> 简单示例：</p>
<pre><code>Path path1 = Paths.get(&quot;d:\\data\\projects&quot;, &quot;.\\a-project&quot;);

Path path2 = Paths.get(&quot;d:\\data\\projects\\a-project&quot;,
        &quot;..\\another-project&quot;);
</code></pre>

<p>Java NIO <code>Path</code> 类有多种方式搭配使用相对路径的方式。你将会在稍后看到更多细节。</p>
<h4><a name="path-normalize"></a> 14.2 Path.normalize()</h4>
<p><code>Path</code> 接口的 <code>normalize()</code> 方法可以标准化一个路径。标准化的意思是，它移除路径字符串中所有的 <code>.</code> 和 <code>..</code>，并解析路径字符串实际指向的路径。下面是一个 <code>Path.normalize()</code> 示例：</p>
<pre><code>String originalPath =
    &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;

Path path1 = Paths.get(originalPath);
System.out.println(&quot;path1 = &quot; + path1);

Path path2 = path1.normalize();
System.out.println(&quot;path2 = &quot; + path2);
</code></pre>

<p>这个 <code>Path</code> 示例首先创建一个中间包含 <code>..</code> 的路径字符串。然后，例子从路径字符串创建一个 <code>Path</code> 实例，并打印这个 <code>Path</code> 实例（实际上它打印 <code>Path.toString()</code>）。</p>
<p>这个例子调用 <code>Path</code> 实例的 <code>normalize()</code> 方法，将会返回一个新 <code>Path</code> 实例。这个新标准化的 <code>Path</code> 实例同样被打印出来。</p>
<p>下面是前面例子的打印输出：</p>
<pre><code>path1 = d:\data\projects\a-project\..\another-project
path2 = d:\data\projects\another-project
</code></pre>

<p>如你所见，标准化后的路径不包含 <code>a-project\..</code> 部分，因为它是冗余的。被移除的部分对最终绝对路径没什么影响。</p>
<h3><a name="Java-NIO-Files"></a> 15. Java NIO Files</h3>
<p>Java NIO <code>Files</code> 类（<code>java.nio.file.Files</code>）提供了一些管理文件系统中文件的方法。Java NIO <code>Files</code> 教程将会覆盖最常用的方法。<code>Files</code> 类包括多个方法，如果你需要没有在这里描述到的方法，请查看 JavaDoc。<code>Files</code> 类只是可能有为了你的某种用途的某个方法。</p>
<p><code>java.nio.file.Files</code> 类搭配 <a href="#Java-NIO-Path"><code>java.nio.file.Path</code></a> 实例使用，所以在你用 <code>Files</code> 类之前，你需要理解 <code>Path</code> 类。</p>
<h4><a name="files-exists"></a> 15.1 Files.exists()</h4>
<p><code>Files.exists()</code> 方法检查给定的 <code>Path</code> 是否在文件系统中存在。</p>
<p>可以创建文件系统中不存在的 <code>Path</code> 实例。比如，如果你计划创建一个新文件夹，你需要首先创建一个关联的 <code>Path</code> 实例，然后创建这个目录。</p>
<p>由于 <code>Path</code> 实例可能指向文件系统上存在或不存在的实际路径，你可以使用 <code>Files.exists()</code> 方法来确定（如果你需要检查的话）。</p>
<p>下面是一个 Java <code>Files.exists()</code> 示例：</p>
<pre><code>Path path = Paths.get(&quot;data/logging.properties&quot;);

boolean pathExists =
    Files.exists(path,
        new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});
</code></pre>

<p>这个例子首先创建一个 <code>Path</code> 实例指向我打算检查是否存在的路径。然后，例子调用 <code>Files.exists()</code> 方法，将 <code>Path</code> 实例作为第一个参数。</p>
<p>注意，<code>Files.exists()</code> 方法的第二个参数。这个参数是一个选项数组，影响 <code>Files.exists()</code> 如何决定一个路径是否存在。</p>
<p>这例子中的数组包括 <code>LinkOption.NOFOLLOW_LINKS</code>，意思是 <code>Files.exists()</code> 不要查看文件系统上的符号链接实际所指路径是否存在。</p>
<h4><a name="files-create-directory"></a> 15.2 Files.createDirectory()</h4>
<p><code>Files.createDirectory()</code> 方法从 <code>Path</code> 实例创建新目录。下面是一个例子：</p>
<pre><code>Path path = Paths.get(&quot;data/subdir&quot;);

try {
    Path newDir = Files.createDirectory(path);
} catch(FileAlreadyExistsException e){
    // the directory already exists.
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}
</code></pre>

<p>第一行创建 <code>Path</code> 实例，表示要被创建的目录。在 <code>try-catch</code> 块内，<code>Files.createDirectory()</code> 方法被调用，并用路径作为参数。如果目录创建成功，<code>Path</code> 实例将被返回，指向新创建的路径。</p>
<p>如果目录已经存在，则将会抛出一个 <code>java.nio.file.FileAlreadyExistsException</code>。如果是其他的错误，将会抛出 <code>IOException</code>。比如，如果一个目标目录的父目录不存在，将会抛出 <code>IOException</code>。父目录是你想新建目录时所在的目录。因而，它表示新目录的父目录。</p>
<h4><a name="files-copy"></a> 15.3 Files.copy()</h4>
<p><code>Files.copy()</code> 方法复制文件从一个路径到另一个。下面是一个 <code>Files.copy()</code> 示例：</p>
<pre><code>Path sourcePath      = Paths.get(&quot;data/logging.properties&quot;);
Path destinationPath = Paths.get(&quot;data/logging-copy.properties&quot;);

try {
    Files.copy(sourcePath, destinationPath);
} catch(FileAlreadyExistsException e) {
    //destination file already exists
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}
</code></pre>

<p>首先例子，创建一个源和目的 <code>Path</code> 实例。然后调用 <code>Files.copy()</code>，将两个 <code>Path</code> 实例作为参数。这个操作的结果是，源路径指向的文件被复制到目的路径指向的文件。</p>
<p>如果目的文件已经存在，则将会抛出一个 <code>java.nio.file.FileAlreadyExistsException</code>。如果是其他的错误，将会抛出 <code>IOException</code>。比如，如果，复制文件所在的目录不存在，将会抛出 <code>IOException</code>。</p>
<h5><a name="overwriting-existing-files"></a> 15.3.1 覆盖已存在文件</h5>
<p>可以强制 <code>Files.copy()</code> 覆盖已存在文件。下面这个例子展示如何通过 <code>Files.copy()</code> 覆盖文件：</p>
<pre><code>Path sourcePath      = Paths.get(&quot;data/logging.properties&quot;);
Path destinationPath = Paths.get(&quot;data/logging-copy.properties&quot;);

try {
    Files.copy(sourcePath, destinationPath,
    StandardCopyOption.REPLACE_EXISTING);
} catch(FileAlreadyExistsException e) {
    //destination file already exists
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}
</code></pre>

<p>注意 <code>Files.copy()</code> 的第三个参数。这个参数指示 <code>copy()</code> 方法覆盖已存在文件。</p>
<h4><a name="files-move"></a> 15.4 Files.move()</h4>
<p>Java NIO <code>Files</code> 类也包含一个函数来从某个路径移动文件到另一个路径。移动文件跟重命名是一样的，除了移动文件可以移动文件到一个不同的目录或是改变它的名字（当前目录下）。是的，通过 <code>java.io.File</code> 类的 <code>renameTo()</code> 方法也可以做到，但是现在你也有一个在 <code>java.nio.file.Files</code> 类下的 <code>move</code> 功能。</p>
<p>下面是一个 <code>Files.move()</code> 的示例：</p>
<pre><code>Path sourcePath      = Paths.get(&quot;data/logging-copy.properties&quot;);
Path destinationPath = Paths.get(&quot;data/subdir/logging-moved.properties&quot;);

try {
    Files.move(sourcePath, destinationPath,
        StandardCopyOption.REPLACE_EXISTING);
} catch (IOException e) {
    //moving file failed.
    e.printStackTrace();
}
</code></pre>

<p>首先，源路径和目的路径被创建。源路径指向将被移动的文件，目的路径指向文件将被移动到的地方。然后 <code>Files.move()</code> 被调用。使文件被移动。</p>
<p>注意传递给 <code>Files.move()</code> 的第三个参数。这个参数告诉告诉 <code>Files.move()</code> 方法来覆盖目的路径的已存在文件。这个参数是可选的。</p>
<p><code>Files.move()</code> 方法可能抛出 <code>IOException</code>，当移动文件失败时。比如，如果文件已经存在，而且你没有使用 <code>StandardCopyOption.REPLACE_EXISTING</code> 选项，或被移动的文件不存在。</p>
<h4><a name="files-delete"></a> 15.5 Files.delete()</h4>
<p><code>Files.delete()</code> 方法可以删除问价或目录。下面是一个示例：</p>
<pre><code>Path path = Paths.get(&quot;data/subdir/logging-moved.properties&quot;);

try {
    Files.delete(path);
} catch (IOException e) {
    //deleting file failed
    e.printStackTrace();
}
</code></pre>

<p>首先，指向被删文件的 <code>Path</code> 被建立。然后，调用 <code>Files.delete()</code> 方法。如果由于某些原因失败（如，文件或目录不存在） <code>Files.delete()</code> 执行失败，将会抛出 <code>IOException</code>。</p>
<h4><a name="files-additional-methods"></a> 15.6 Files 类中其他方法</h4>
<p><code>java.nio.file.Files</code> 类包含许多实用函数，如创建符号链接，检查文件大小，设置权限等。关于这些方法的细节查看 <code>java.nio.file.Files</code> 类的 JavaDoc。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
